{"id":"bd-10i","title":"FrankenTUI: Complete Implementation Epic","description":"# FrankenTUI (ftui) - Master Epic\n\n## Vision\nFrankenTUI is a deliberately minimal, high-performance terminal UI kernel that fuses the best surviving abstractions from three Rust codebases (rich_rust, charmed_rust, opentui_rust) into one coherent system.\n\n## Core Promise\nftui is designed so you can build a Claude Code / Codex-class agent harness UI without flicker, without cursor corruption, and without sacrificing native scrollback.\n\n## Three-Library Synthesis\n- opentui_rust: Cell grid, diff algorithm, alpha blending, scissor/opacity stacks, grapheme pool (cache-optimal 16-byte cells)\n- rich_rust: Segment abstraction, markup parser, measurement protocol (Cow<str> for zero-copy)\n- charmed_rust: LipGloss styling, CSS-like properties, theme system, Elm architecture (bitflags property tracking)\n\n## Non-Negotiables (Engineering Contract)\n1. One writer owns the terminal - serialized output\n2. Untrusted bytes never executed - sanitize by default\n3. Diffed + buffered UI only - no ad-hoc println\n4. Inline-first is real - preserve scrollback\n5. Safe by default, unsafe isolated\n6. Deterministic by design\n7. Correctness continuously verified\n\n## Performance Budgets\n- Present (80x24, 5% changed): p50 < 1.0ms\n- Cell comparison: < 1ns\n- 16 bytes per cell (4 per cache line)\n\nThis epic tracks all work required to ship ftui v1.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-31T22:04:22.713361602Z","created_by":"ubuntu","updated_at":"2026-01-31T22:04:22.713361602Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-10i.1","title":"Phase -1: Decision Spikes","description":"# Phase -1: Decision Spikes\n\n## Purpose\nBefore building a big structure, run small spikes that de-risk the hardest unknowns. These are tiny experiments for fast learning.\n\n## Why This Phase Exists\nThe plan is ambitious and certain decisions could cause multi-week churn if not resolved early. Decision spikes force us to confront reality before committing to architecture.\n\n## Exit Criteria\nOne ADR (Architecture Decision Record) per spike capturing:\n- Context: What problem are we solving?\n- Decision: What did we choose?\n- Alternatives considered\n- Consequences: What are the tradeoffs?\n- Test plan: How we'll know it worked\n\n## Key Spikes Required\n1. Inline mode spike: Implement both scroll-region and overlay strategies in tiny prototype\n2. Presenter validation spike: Build terminal-model harness to validate output\n3. Backend spike: Validate raw mode + resize + input reading across platforms\n\n## Relationship to Other Phases\nThis phase BLOCKS Phase 0 (Contracts + Workspace Skeleton). We must not proceed with architecture until we've validated our assumptions through concrete experiments.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:04:34.363862676Z","created_by":"ubuntu","updated_at":"2026-01-31T22:04:34.363862676Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.1","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:04:34.363862676Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.1.1","title":"Spike: Inline Mode Strategies","description":"# Spike: Inline Mode Strategies\n\n## Objective\nImplement both scroll-region and overlay strategies in a tiny prototype. Verify behavior across terminal environments. Choose a default strategy and document fallback rules.\n\n## Background: Why Inline Mode is Hard\nInline mode + streaming logs is where most TUIs become flaky:\n- Logs write while UI is mid-draw\n- Cursor gets lost\n- Scrollback gets wiped by 'helpful' full clear\n- tmux/screen complicate cursor save/restore and margins\n\n## Strategy A: Scroll-Region Anchoring (DECSTBM)\nUse CSI t ; b r to set top/bottom margins:\n- Constrains scrolling to log region\n- UI region stays pinned while logs scroll above\n- Pros: fewer redraws, less cursor thrash\n- Cons: varies under tmux/screen, must reset on exit\n\n## Strategy B: Overlay Redraw (Universal Fallback)\nBefore writing logs:\n- Save cursor position\n- Clear/hide UI region\n- Write logs normally (enters scrollback)\n- Redraw UI region\n- Restore cursor\n- Pros: works nearly everywhere\n- Cons: more redraw work\n\n## Strategy C: Hybrid (Recommended Default)\n- Overlay redraw is always available as correctness baseline\n- Scroll-region anchoring is internal optimization when proven safe\n- Public API exposes policy, not mechanism\n\n## Test Environments\n1. Plain terminal (xterm, native macOS Terminal)\n2. Modern terminals (Kitty, WezTerm, Alacritty, Ghostty)\n3. tmux (most common mux)\n4. screen (legacy mux)\n\n## Deliverable\n- Tiny prototype (~200 LOC) that demonstrates both strategies\n- PTY test harness to verify behavior\n- ADR-001 document with decision and rationale\n\n## Success Criteria\n- Prototype shows no cursor drift under sustained log output\n- Strategy selection logic documented\n- tmux behavior characterized and fallback rules defined","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:07:24.429895270Z","created_by":"ubuntu","updated_at":"2026-01-31T22:07:24.429895270Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.1.1","depends_on_id":"bd-10i.1","type":"parent-child","created_at":"2026-01-31T22:07:24.429895270Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.1.2","title":"Spike: Presenter Validation with Terminal Model","description":"# Spike: Presenter Validation with Terminal Model\n\n## Objective\nBuild a terminal-model harness (subset of escape sequences) and validate that a present cycle produces expected grid + cursor behavior.\n\n## Why This Spike Matters\nThe Presenter is the translation layer between our internal model and the terminal. If it emits incorrect sequences:\n- Styles leak across cells\n- Cursor ends up in wrong position\n- Links remain open after they should close\n- Screen corruption under edge cases\n\nWe need a way to prove correctness without relying on visual inspection.\n\n## Terminal Model Approach\nBuild a minimal terminal emulator in Rust that:\n- Tracks a grid of cells (just like our Buffer)\n- Tracks cursor position\n- Tracks current SGR state (style)\n- Tracks current link state (OSC 8)\n- Parses and applies ANSI sequences\n\nThis is NOT a full terminal emulator - just enough to validate our output.\n\n## Sequences to Support in Model\n- CUP (cursor position): CSI r ; c H\n- SGR (style): CSI n ; n ; ... m\n- ED (erase display): CSI n J\n- EL (erase line): CSI n K\n- OSC 8 (hyperlinks): OSC 8 ; ; url ST\n- Sync output: CSI ? 2026 h/l\n\n## Test Approach\n1. Create a Buffer with known content\n2. Run through Presenter to get ANSI output\n3. Feed output through terminal model\n4. Assert model's grid matches our Buffer\n5. Assert cursor position is correct\n6. Assert no dangling style/link state\n\n## Deliverable\n- TerminalModel struct with grid, cursor, style tracking\n- Property tests: random Buffer -> Presenter -> Model -> assert equality\n- Foundation for ongoing correctness testing\n\n## Success Criteria\n- Model correctly interprets all Presenter output\n- Property tests find no discrepancies\n- Framework ready for use in CI","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:07:38.682217640Z","created_by":"ubuntu","updated_at":"2026-01-31T22:07:38.682217640Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.1.2","depends_on_id":"bd-10i.1","type":"parent-child","created_at":"2026-01-31T22:07:38.682217640Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.1.3","title":"Spike: Terminal Backend Validation","description":"# Spike: Terminal Backend Validation\n\n## Objective\nValidate raw mode + resize + input reading across platforms with candidate backend (Crossterm). Confirm it meets our needs or identify gaps.\n\n## Why This Spike Matters\nThe terminal backend is foundational:\n- Raw mode enter/exit must be reliable\n- Resize events must be delivered correctly\n- Input parsing must work with our Event types\n- Cleanup on panic must work\n\nIf we choose wrong, we'll be fighting the backend throughout development.\n\n## Crossterm Evaluation Criteria\n\n### Functionality\n- [ ] Raw mode enter/exit\n- [ ] Resize event delivery\n- [ ] Key event parsing (standard + extended)\n- [ ] Mouse event parsing (SGR mode)\n- [ ] Bracketed paste handling\n- [ ] Focus events\n\n### Platform Coverage\n- [ ] Linux (primary)\n- [ ] macOS\n- [ ] Windows (basic support acceptable)\n\n### Panic Recovery\n- [ ] Can we hook into panic for cleanup?\n- [ ] Does Drop work reliably?\n\n### API Ergonomics\n- [ ] Can we hide Crossterm behind our abstractions?\n- [ ] Does it fit our Event model?\n\n## Alternative Backends to Consider\n- termion: Unix-only but simpler\n- raw custom termios: maximum control but more work\n- termwiz: another option worth evaluating\n\n## Test Approach\n1. Build minimal wrapper around Crossterm\n2. Test on Linux, macOS, Windows\n3. Verify resize delivery under window resize\n4. Verify panic cleanup with forced panic\n5. Verify mouse + keyboard input parsing\n\n## Deliverable\n- Evaluation document with findings\n- Minimal TerminalBackend trait design\n- ADR-003 decision with rationale\n\n## Success Criteria\n- Confident choice of backend for v1\n- Known limitations documented\n- Path to alternative backends if needed","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:07:51.564188110Z","created_by":"ubuntu","updated_at":"2026-01-31T22:07:51.564188110Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.1.3","depends_on_id":"bd-10i.1","type":"parent-child","created_at":"2026-01-31T22:07:51.564188110Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10","title":"ADRs: Architecture Decision Records","description":"# ADRs: Architecture Decision Records\n\n## Purpose\nLock the 'churn-magnets' - decisions that most often cause multi-week churn if not resolved early. Each ADR follows the format:\n- Context\n- Decision\n- Alternatives considered\n- Consequences\n- Test plan\n\n## Why ADRs Matter\nThese are not bureaucratic paperwork. They are the decisions that:\n- Could cause weeks of refactoring if changed later\n- Have non-obvious tradeoffs\n- Need documented rationale for future contributors\n- Serve as the 'why' behind the code\n\n## ADRs Required for v1\n\n### ADR-001: Inline Mode Strategy\nHybrid anchoring: overlay redraw baseline + scroll-region optimization\n- Most impactful decision for agent harness behavior\n\n### ADR-002: Presenter Emission Strategy\nReset+apply for v1 correctness; incremental behind feature flag\n- Affects output size and correctness guarantees\n\n### ADR-003: Terminal Backend Selection\nCrossterm as v1 default\n- Affects portability and maintenance burden\n\n### ADR-004: Windows v1 Scope\nWhat's supported vs best-effort\n- Sets user expectations and testing requirements\n\n### ADR-005: One-Writer Rule Enforcement\nType-level ownership model\n- Core correctness invariant for inline mode\n\n### ADR-006: Untrusted Output Policy\nSanitize-by-default for security\n- Prevents escape sequence injection attacks\n\n## ADR Discipline Rules\n- Every controversial design choice gets an ADR\n- ADRs are short and opinionated\n- Once written and reviewed, ADRs are locked\n- Changes require new ADR or amendment with rationale","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-31T22:06:50.475979143Z","created_by":"ubuntu","updated_at":"2026-01-31T22:06:50.475979143Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:06:50.475979143Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.1","title":"ADR-001: Inline Mode Strategy","description":"# ADR-001: Inline Mode Strategy\n\n## Status\nPROPOSED\n\n## Context\nWe need stable UI chrome + scrollback-native logs, with no flicker or cursor corruption, across terminals and multiplexers.\n\nInline mode plus streaming output is the hardest real-world requirement. Most flicker/corruption bugs come from broken assumptions about terminal ownership and write interleaving.\n\n## Options Considered\n\n### Option A: Scroll-Region Anchoring (DECSTBM)\n- Pros: UI truly pinned, logs scroll naturally, fewer UI redraws\n- Cons: Tricky interactions (cursor save/restore, origin mode), mux quirks, needs serious PTY coverage\n\n### Option B: Overlay Redraw\n- Pros: Portable baseline, correctness-first, simplest mental model\n- Cons: Needs careful 'clear only UI region', buffered output to avoid flicker\n\n### Option C: Hybrid (RECOMMENDED)\n- Pros: Best of both; baseline works everywhere, optimization where safe\n- Cons: Complexity; requires capability policy and more tests\n\n## Decision\n**Hybrid approach**:\n1. Overlay redraw is always available and is the correctness baseline\n2. Scroll-region anchoring is an internal optimization enabled only when proven safe\n3. Public API exposes policy, not mechanism\n\n## Implementation Notes (Baseline Overlay)\n1. Begin synchronized output if supported\n2. Save cursor position (prefer robust option)\n3. Move cursor to UI anchor\n4. Clear only the UI region (localized EL/ED)\n5. Present diffed UI frame\n6. Restore cursor position\n7. End synchronized output; flush\n\n## Implementation Notes (Scroll-Region Optimization)\nWhen enabled:\n- Set scroll region to log area: top..(h-ui_height)\n- Ensure UI writes land outside scroll region\n- Restore scroll region on exit and mode switches\n- Disable by default in tmux/screen\n\n## Consequences\n- More complex than pure overlay or pure scroll-region\n- Requires capability detection and policy logic\n- Requires PTY tests for both strategies\n- Better user experience when optimization is safe\n\n## Test Plan\n- PTY test: log spam + UI tick does not corrupt scrollback\n- Cursor contract test: cursor restored after every present\n- Resize test: changing ui_height and terminal height re-anchors correctly\n- Mux tests: verify tmux/screen behavior and fallback","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:08:10.132311732Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:35.588316533Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.1","depends_on_id":"bd-10i.1.1","type":"blocks","created_at":"2026-01-31T22:21:35.588286787Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.10.1","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:08:10.132311732Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.2","title":"ADR-002: Presenter Emission Strategy","description":"# ADR-002: Presenter Emission Strategy\n\n## Status\nPROPOSED\n\n## Context\nSGR and link state tracking can either be simple and correct or minimal-bytes and complex. The Presenter must emit ANSI sequences that transform the terminal from current state to desired state.\n\n## Options Considered\n\n### Option A: Reset+Apply Always\nEmit SGR 0 then re-apply all attributes for each style change.\n- Pros: Simplest, correctness is trivial\n- Cons: More bytes emitted\n\n### Option B: Incremental SGR Diffs\nTrack previous style, emit only changed attributes.\n- Pros: Fewer bytes, faster on slow terminals\n- Cons: Complex, risk of 'dangling attributes' bugs\n\n### Option C: Hybrid (RECOMMENDED for future)\nReset on hard cases, incremental on small diffs.\n- Pros: Best of both\n- Cons: Needs heuristics and benchmarks\n\n## Decision\n**v1 default: Reset+Apply** for correctness.\n**Add incremental/hybrid behind feature flag** until benchmarks + PTY coverage justify enabling by default.\n\n## Rationale\nCorrectness beats optimization at this stage. Reset+apply is:\n- Trivially correct\n- Easy to test and verify\n- Good enough for most workloads\n- Foundation for future optimization\n\nIncremental emission can be added later when:\n- We have comprehensive terminal-model tests\n- Benchmarks show meaningful benefit\n- PTY tests cover edge cases\n\n## Consequences\n- Higher byte output than theoretically minimal\n- Simpler implementation and maintenance\n- Clear path to optimization via feature flag\n- No 'dangling attribute' bugs possible\n\n## Test Plan\n- Terminal-model tests: style state cannot leak across runs\n- PTY tests: links (OSC 8) cannot remain open after present/exit\n- Benchmark: measure bytes/frame for representative workloads\n- Regression: track byte output in CI","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:08:24.426412320Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:35.878559287Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.2","depends_on_id":"bd-10i.1.2","type":"blocks","created_at":"2026-01-31T22:21:35.878528890Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.10.2","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:08:24.426412320Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.3","title":"ADR-003: Terminal Backend Selection","description":"# ADR-003: Terminal Backend Selection\n\n## Status\nPROPOSED\n\n## Context\nWe must support raw mode, key/mouse input, resize, and reliable cleanup on Unix and Windows.\n\n## Options Considered\n\n### Option A: Crossterm\n- Pros: Widely used, cross-platform, avoids bespoke termios/Windows plumbing\n- Cons: Another dependency, abstractions may not fit perfectly\n\n### Option B: termion\n- Pros: Pure Rust, simpler\n- Cons: Unix-only, no Windows support\n\n### Option C: Raw termios + Windows Console API\n- Pros: Maximum control\n- Cons: Significant implementation effort, platform-specific code\n\n### Option D: termwiz\n- Pros: Feature-rich, from wezterm project\n- Cons: Heavier dependency, may include more than we need\n\n## Decision\n**v1 default: Crossterm**\n\nKernel remains backend-agnostic at the conceptual level, but v1 does NOT over-abstract. Ship one backend 'batteries included'; treat alternatives as experimental.\n\n## Rationale\n- Crossterm is widely used and tested\n- Cross-platform without custom code\n- Fits our Event model reasonably well\n- Community support and maintenance\n- We can switch later if needed (abstraction in place)\n\n## Consequences\n- Dependency on crossterm crate\n- Must work within crossterm's event model\n- Windows support comes 'for free' (with caveats)\n- Path to alternatives via feature flags\n\n## Test Plan\n- Spike validates Crossterm functionality (bd-10i.1.3)\n- PTY tests verify raw mode + cleanup\n- Multi-platform CI (Linux, macOS, Windows)\n- Document any Crossterm limitations in Windows ADR","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:08:38.701607178Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:36.119899484Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.3","depends_on_id":"bd-10i.1.3","type":"blocks","created_at":"2026-01-31T22:21:36.119868797Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.10.3","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:08:38.701607178Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.4","title":"ADR-004: Windows v1 Scope","description":"# ADR-004: Windows v1 Scope\n\n## Status\nPROPOSED\n\n## Context\nWindows terminal support varies significantly from Unix. We need to decide what's fully supported vs best-effort for v1.\n\n## Supported in v1\n- Raw mode enter/exit and cleanup on panic\n- Key input and resize events\n- Basic mouse (where Crossterm supports it)\n- Color where available (16/256/truecolor when exposed)\n\n## Best-Effort / May Be Missing in v1\n- DEC synchronized output (mode 2026) - not widely supported\n- OSC 8 hyperlinks - limited Windows Terminal support\n- Bracketed paste differences across terminals\n- Focus events differences\n- Kitty keyboard protocol - not supported\n\n## Decision\nAccept Windows as 'supported with documented limitations' for v1.\n\n## Rationale\n- Primary target is agent harness UIs (likely Unix/macOS)\n- Windows Terminal is improving but not at feature parity\n- Full Windows feature parity would delay v1 significantly\n- Honest documentation is better than broken promises\n\n## Consequences\n- Windows users may have reduced functionality\n- Must clearly document limitations\n- Future versions can improve Windows support\n- CI must include Windows builds (even if tests are limited)\n\n## Documentation Requirement\nA 'Windows Limitations' section must exist and be honest about:\n- Which features work fully\n- Which features are degraded\n- Which features are missing\n- Workarounds if any\n\n## Test Plan\n- Windows CI build must pass\n- Core functionality tests on Windows (raw mode, basic input)\n- Document behavior differences","status":"open","priority":1,"issue_type":"docs","created_at":"2026-01-31T22:08:51.697779300Z","created_by":"ubuntu","updated_at":"2026-01-31T22:08:51.697779300Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.4","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:08:51.697779300Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.5","title":"ADR-005: One-Writer Rule Enforcement","description":"# ADR-005: One-Writer Rule Enforcement\n\n## Status\nPROPOSED\n\n## Context\nInline mode guarantees break if other code writes to stdout/stderr concurrently. The terminal is a shared mutable resource that doesn't support concurrent access safely.\n\n## Problem\nIf multiple sources write to the terminal simultaneously:\n- Cursor position becomes undefined\n- Partial escape sequences corrupt output\n- UI and logs interleave unpredictably\n- Scrollback gets corrupted\n\n## Decision\nEnforce the one-writer rule through type-level ownership:\n- TerminalOwner / TerminalSession owns raw mode and output handle\n- TerminalWriter is the only way to write logs and present UI\n- Provide routing helpers for subprocess and in-process logs\n\n## Type-Level Enforcement\nTerminalSession takes ownership of stdout:\n- Only TerminalWriter can produce output\n- Cannot accidentally println! while ftui is active\n- Drop returns terminal to normal state\n\n## Supported Routing Patterns\n\n### Pattern A: LogSink (In-Process Logs)\nProvide a LogSink: Write that application code uses instead of println!\n- Discourage raw println! during inline mode\n- Route through TerminalWriter with sanitization\n\n### Pattern B: PTY Capture (Subprocess Output)\nSpawn tool subprocesses under PTY:\n- Read their stdout/stderr streams\n- Write as log stream through ftui\n- Preserves scrollback and UI stability\n- Feature-gated (adds dependency on PTY crate)\n\n### Pattern C: Stdio Capture (Optional)\nPipe + reader thread that forwards through ftui:\n- Captures accidental println! from libraries\n- Best-effort, may miss some output\n- Feature-gated\n\n## Consequences\n- Application code must use ftui APIs for output\n- Libraries that write directly may cause issues\n- Subprocess output requires explicit handling\n- More disciplined but more work for users\n\n## What Happens If Violated\nIf external code writes to stdout during inline mode:\n- Behavior is undefined\n- Cursor may drift\n- UI may corrupt\n- This is documented as unsupported\n\n## Test Plan\n- PTY tests with concurrent log writes via supported mux path\n- Assert stability under parallel output\n- Document undefined behavior for unsupported patterns","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:09:09.275630145Z","created_by":"ubuntu","updated_at":"2026-01-31T22:09:09.275630145Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.5","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:09:09.275630145Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.6","title":"ADR-006: Untrusted Output Policy (Sanitize-by-Default)","description":"# ADR-006: Untrusted Output Policy (Sanitize-by-Default)\n\n## Status\nPROPOSED\n\n## Context\nAgent harnesses display tool output, LLM streams, and logs. Malicious or buggy content can smuggle ANSI/OSC sequences that:\n- Manipulate terminal state\n- Deceive users (fake prompts, hidden commands)\n- Persist changes after the app exits\n- Exfiltrate data via terminal queries\n\nThis is a real security concern for AI agent UIs.\n\n## Decision\n**Sanitize by default**: Any text flowing through write_log() or rendered as user-provided content has control sequences stripped or escaped.\n\n**Explicit opt-in for raw passthrough**: An API like write_raw() or Text::raw() allows trusted content to include ANSI.\n\n## What Gets Sanitized\n- ESC (0x1B) and all CSI/OSC/DCS/APC sequences\n- C0 controls except: TAB (0x09), LF (0x0A), CR (0x0D)\n- Option for semi-trusted mode: allow SGR styling only\n\n## Sanitization Strategies\n1. **Strip**: Remove escape sequences entirely\n2. **Escape**: Convert to visible representation (e.g., ^[ for ESC)\n3. **Replace**: Substitute with placeholder character\n\nDefault: Strip (cleanest output)\n\n## API Design\n// Sanitized by default\nharness.write_log('User provided text with \\x1b[31mattack\\x1b[0m');\n// -> 'User provided text with attack'\n\n// Explicit opt-in for trusted content\nharness.write_raw(trusted_ansi_bytes);\n\n// Text with explicit trust level\nText::sanitized(user_input);\nText::raw(trusted_source);\n\n## Consequences\n- User content is safe by default\n- Trusted content must be explicitly marked\n- Some legitimate ANSI in logs will be stripped\n- Security posture matches threat model\n\n## Test Plan\n- PTY tests feeding adversarial sequences into logs\n- Assert terminal invariants remain intact\n- Fuzz tests with random byte streams in log paths\n- Verify no state leakage after malicious input","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:09:25.501690222Z","created_by":"ubuntu","updated_at":"2026-01-31T22:09:25.501690222Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.6","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:09:25.501690222Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.11","title":"Testing + QA: Verification Suite","description":"# Testing + QA: Verification Suite\n\n## Purpose\nKernel must be 'boringly correct'. Testing is not optional - it's how we prove our claims and prevent regressions.\n\n## Test Categories\n\n### Unit Tests (Kernel)\n- Cell packing/equality\n- Buffer bounds + scissor/opacity invariants\n- GraphemePool refcount correctness\n- LinkRegistry correctness\n- Width measurement accuracy\n\n### Property Tests (Randomized)\n- Diff correctness: applying changes reproduces target buffer\n- Presenter state tracking never emits malformed sequences\n- Width correctness: rendering never writes beyond frame bounds\n\n### Snapshot Tests (Widgets/Apps)\n- Frame buffers across themes and widths\n- Segment streams for export pipelines\n- Deterministic outputs in simulator mode\n\n### PTY Integration Tests (Terminal Reality)\nSpawn a PTY, run minimal ftui app, capture output, assert:\n- Cursor restored after each present() in Inline mode\n- Raw mode restored on exit\n- Cursor visibility restored (show cursor)\n- Bracketed paste/mouse modes disabled on exit\n- Alt screen exited on exit\n\nTest scenarios:\n- Normal exit\n- Panic during render\n- IO error mid-write\n\n### Fuzzing (Input Parser)\n- Random byte streams\n- No panics\n- Sequence length limits enforced\n- Linear time for worst-case inputs\n\n### Terminal-Model Tests\nValidate presenter output by:\n- Building a terminal emulator model (subset of sequences)\n- Running presenter output through model\n- Asserting resulting grid + cursor state matches expected\n\n## Quality Gates (Stop-Ship)\n1. Inline mode stability - no cursor corruption\n2. Diff/presenter correctness - terminal-model passes\n3. Unicode width correctness - ZWJ/emoji corpus passes\n4. Terminal cleanup - PTY tests verify panic cleanup\n\n## CI Enforcement\n- clippy + fmt\n- All test categories run\n- Performance benchmarks tracked (non-blocking initially)\n- Feature matrix: default, +simd, +extras","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:07:07.502368766Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:29.525126246Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.11","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:07:07.502368766Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T22:21:29.525092512Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.11.1","title":"Build terminal-model test harness","description":"# Build terminal-model test harness\n\n## Objective\nCreate a minimal terminal emulator model for validating Presenter output without relying on actual terminals.\n\n## Why Terminal-Model Testing?\n- PTY tests are slow and flaky\n- Need to verify correctness deterministically\n- Can property-test with random buffers\n- Catches subtle sequence ordering issues\n\n## Terminal Model Scope (Minimal)\nSupport only the sequences Presenter emits:\n- CUP: cursor position (CSI r;c H)\n- SGR: style (CSI n;n;...m)\n- ED: erase display (CSI J) - basic\n- EL: erase line (CSI K) - basic\n- OSC 8: hyperlinks\n- Character output (UTF-8)\n\nNOT supporting (out of scope):\n- Full VT100/xterm emulation\n- Scrolling, tabs, alternate charset\n- DCS, APC sequences\n\n## Structure\npub struct TerminalModel {\n    width: u16,\n    height: u16,\n    cells: Vec<ModelCell>,\n    cursor_x: u16,\n    cursor_y: u16,\n    current_style: ModelStyle,\n    current_link: Option<String>,\n}\n\nstruct ModelCell {\n    content: String,  // Grapheme\n    style: ModelStyle,\n    link: Option<String>,\n}\n\nstruct ModelStyle {\n    fg: Option<(u8, u8, u8)>,\n    bg: Option<(u8, u8, u8)>,\n    bold: bool,\n    italic: bool,\n    underline: bool,\n    // ... other attrs\n}\n\n## Sequence Parser\npub fn apply_output(&mut self, bytes: &[u8]) -> Result<(), ParseError>\n\nParse byte stream, apply to model:\n1. Detect escape sequences\n2. Parse parameters\n3. Apply to grid/cursor/style\n\n## Comparison with Buffer\npub fn matches(&self, buffer: &Buffer, pool: &GraphemePool) -> bool\n\nCompare model grid with ftui Buffer:\n- Check each cell content matches\n- Check styles match (with tolerance for default)\n- Check links match\n\n## Test Pattern\n1. Create Buffer with known content\n2. Run through Presenter -> bytes\n3. Apply bytes to fresh TerminalModel\n4. Assert model.matches(buffer)\n\n## Property Testing\nproptest! {\n    fn presenter_roundtrip(buffer: Buffer) {\n        let mut model = TerminalModel::new(buffer.width(), buffer.height());\n        let bytes = present_to_bytes(&buffer);\n        model.apply_output(&bytes).unwrap();\n        assert!(model.matches(&buffer));\n    }\n}\n\n## Tests Required\n- [ ] CUP positions cursor correctly\n- [ ] SGR sets style attributes\n- [ ] Character output advances cursor\n- [ ] Wide chars handled correctly\n- [ ] OSC 8 links tracked\n- [ ] Complete roundtrip works\n\n## Acceptance Criteria\n- [ ] Property tests pass with random buffers\n- [ ] No false positives (model matches bad output)\n- [ ] Clear error messages on mismatch","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:15:13.041157455Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:44.712002706Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.11.1","depends_on_id":"bd-10i.11","type":"parent-child","created_at":"2026-01-31T22:15:13.041157455Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11.1","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:22:44.711973170Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.11.2","title":"Create PTY test framework (ftui-pty)","description":"# Create PTY test framework (ftui-pty)\n\n## Objective\nBuild a test utility crate for running ftui apps in a PTY and validating terminal behavior.\n\n## Why PTY Tests?\n- Verify real terminal behavior\n- Test cleanup on panic\n- Test cursor restoration\n- Validate inline mode\n- Catch issues terminal-model can't\n\n## PTY Test Capabilities\n\n### Spawn App in PTY\npub fn spawn_app<F>(f: F) -> PtySession\nwhere F: FnOnce(&mut TerminalSession) -> io::Result<()>\n\n- Fork process\n- Set up PTY pair\n- Run closure in child\n- Capture output in parent\n\n### Capture Terminal Output\nimpl PtySession {\n    fn read_output(&mut self) -> Vec<u8>;\n    fn read_until(&mut self, pattern: &[u8], timeout: Duration) -> Result<Vec<u8>>;\n    fn send_input(&mut self, bytes: &[u8]);\n    fn wait(&mut self) -> ExitStatus;\n}\n\n### Assert Terminal State\nAfter app exits, verify terminal is restored:\npub fn assert_terminal_restored(output: &[u8]) {\n    // Check for:\n    // - SGR 0 (reset style)\n    // - CSI ? 25 h (show cursor)\n    // - CSI ? 1049 l (exit alt screen) if was used\n    // - CSI ? 1000 l (disable mouse) if was enabled\n    // - CSI ? 2004 l (disable bracketed paste) if was enabled\n}\n\n### Test Panic Cleanup\n#[test]\nfn panic_cleanup() {\n    let session = spawn_app(|term| {\n        term.enter_raw_mode()?;\n        term.enable_mouse()?;\n        panic\\!('deliberate panic');\n    });\n\n    let output = session.read_output();\n    assert_terminal_restored(&output);\n}\n\n## Inline Mode Tests\n\n### Test Cursor Contract\n#[test]\nfn inline_cursor_restored() {\n    let session = spawn_app(|term| {\n        let harness = AgentHarness::new(ScreenMode::Inline { ui_height: 3 });\n        // Write logs and present UI multiple times\n        for _ in 0..100 {\n            harness.write_log('log line\\n')?;\n            harness.present()?;\n        }\n        // Cursor should be at consistent position\n        Ok(())\n    });\n\n    // Verify no cursor drift in output\n    assert_cursor_stable(&session.output);\n}\n\n### Test Scrollback Preservation\n#[test]\nfn inline_scrollback_preserved() {\n    // Verify scrollback content not corrupted\n    // by inline mode rendering\n}\n\n## Platform Considerations\n- Use nix crate for Unix PTY\n- Windows: may need ConPTY or skip tests\n- CI: ensure PTY available (not all containers have it)\n\n## Tests Required\n- [ ] spawn_app works on Linux/macOS\n- [ ] Normal exit restores terminal\n- [ ] Panic exit restores terminal\n- [ ] Inline mode cursor contract\n- [ ] Alt screen enter/exit\n- [ ] Mouse mode cleanup\n\n## Acceptance Criteria\n- [ ] Framework usable in other test modules\n- [ ] CI can run PTY tests\n- [ ] Cleanup verified for all exit paths","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:15:31.768264464Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:45.226382715Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.11.2","depends_on_id":"bd-10i.11","type":"parent-child","created_at":"2026-01-31T22:15:31.768264464Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11.2","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T22:22:44.982133948Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11.2","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T22:22:45.226347218Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.11.3","title":"Implement input parser fuzzing","description":"# Implement input parser fuzzing\n\n## Objective\nFuzz the InputParser to ensure it handles all possible byte sequences without panicking or excessive resource usage.\n\n## Why Fuzzing?\n- Terminal input is untrusted\n- Malformed sequences are common\n- DoS via crafted input is possible\n- Parser must be robust\n\n## Fuzz Targets\n\n### Target 1: Raw Byte Parsing\nfuzz_target\\!(|data: &[u8]| {\n    let mut parser = InputParser::new();\n    let _ = parser.parse(data);\n    // Must not panic\n    // Must not hang\n    // Must not exceed memory limits\n});\n\n### Target 2: Structured Fuzzing\n// Generate semi-valid sequences\n#[derive(Arbitrary)]\nenum FuzzSequence {\n    Char(u8),\n    Escape,\n    Csi(Vec<u8>),\n    Osc(Vec<u8>),\n    Mouse { button: u8, x: u16, y: u16 },\n    Paste(Vec<u8>),\n}\n\n### Target 3: Long Sequences\n// Specifically test DoS limits\nfuzz_target\\!(|len: u16| {\n    let data = vec\\![0x1b, b'[']  // CSI\n        .into_iter()\n        .chain(std::iter::repeat(b'0').take(len as usize))\n        .chain(std::iter::once(b'm'))\n        .collect::<Vec<_>>();\n\n    let mut parser = InputParser::new();\n    let _ = parser.parse(&data);\n    // Should not allocate unbounded memory\n});\n\n## Properties to Verify\n1. No panics on any input\n2. Memory bounded (no OOM from crafted input)\n3. Time bounded (no quadratic behavior)\n4. Always returns to Ground state eventually\n5. DoS limits enforced\n\n## Corpus Seeds\n- Valid key sequences\n- Valid mouse sequences\n- Bracketed paste boundaries\n- OSC 8 links\n- Malformed UTF-8\n- Truncated sequences\n\n## Running Fuzzer\ncargo +nightly fuzz run input_parser -- -max_len=4096\n\n## Integration with CI\n- Run fuzzer for limited time on each PR\n- Maintain corpus in repo\n- Report new crashes immediately\n\n## Tests Required\n- [ ] Fuzz harness builds\n- [ ] Initial corpus covers major cases\n- [ ] No crashes in 1-hour fuzz session\n- [ ] Memory limits enforced\n\n## Acceptance Criteria\n- [ ] Fuzzer integrated in CI\n- [ ] No panics found\n- [ ] Corpus maintained\n- [ ] Coverage tracked","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:15:47.811194117Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:45.486723842Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.11.3","depends_on_id":"bd-10i.11","type":"parent-child","created_at":"2026-01-31T22:15:47.811194117Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11.3","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T22:22:45.486693585Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2","title":"Phase 0: Contracts + Workspace Skeleton","description":"# Phase 0: Contracts + Workspace Skeleton\n\n## Purpose\nEstablish the foundational structure before any implementation. This phase creates the workspace layout, defines public contracts, and documents locked decisions via ADRs.\n\n## Deliverables\n1. Workspace crate layout (ftui-core/render/style/text/layout/runtime/widgets/extras)\n2. Public contracts for kernel types: Cell, Buffer, Frame, Presenter, TerminalSession, Event\n3. ADRs for all locked decisions from Section 0.6 of the plan\n4. ftui facade crate with thin stable API surface\n5. forbid(unsafe_code) in all crates except optional ftui-simd\n\n## Exit Criteria\n- Public API compiles\n- Minimal demo crate prints a frame in Inline mode\n- All ADRs written and reviewed\n\n## Why This Phase Matters\nWithout clear contracts and workspace organization, the project will accumulate accidental complexity. This phase forces us to commit to boundaries and interfaces before writing implementation code.\n\n## Workspace Crate Layout (Target)\n- ftui: facade/public API (re-exports stable types)\n- ftui-core: raw mode, lifecycle guards, capability detection, input parsing, screen mode policy\n- ftui-render: Cell, Buffer, Frame, GraphemePool, LinkRegistry, HitGrid, Diff engine, Presenter\n- ftui-style: TextStyle, CellStyle, Theme, semantic colors, color downgrade\n- ftui-text: Text, Span, Segment, width measurement, wrapping, truncation, alignment\n- ftui-layout: Rect, constraints, row/col/grid layout, measurement protocol\n- ftui-runtime: Bubbletea/Elm-like Program, Model, Cmd, scheduler, simulator\n- ftui-widgets: Component library (feature-gated)\n- ftui-extras: Markdown, syntax highlighting, export, SSH, forms (feature-gated)\n- ftui-harness: Agent harness reference implementation\n- ftui-simd: Optional unsafe hot loops (isolated, feature-gated)\n- ftui-pty: Test-only PTY utilities","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:04:51.251200646Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:20.320849503Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:04:51.251200646Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2","depends_on_id":"bd-10i.1","type":"blocks","created_at":"2026-01-31T22:21:20.041547122Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2","depends_on_id":"bd-10i.10","type":"blocks","created_at":"2026-01-31T22:21:20.320818635Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.1","title":"Create Cargo workspace with crate layout","description":"# Create Cargo workspace with crate layout\n\n## Objective\nSet up the multi-crate workspace structure that enforces layering boundaries.\n\n## Crate Layout\n\n### ftui (facade)\n- Re-exports stable public types (App, ScreenMode, Event, Frame, Style)\n- Provides prelude, ergonomic builders, sensible defaults\n- What most apps depend on\n\n### ftui-core\n- Raw mode + terminal lifecycle guards (RAII)\n- Capability detection (env heuristics + optional queries)\n- Input parsing into canonical Event\n- Screen mode policy helpers (Inline/AltScreen)\n\n### ftui-render\n- Cell, Buffer, Frame (Frame = buffer + optional hit grid + metadata)\n- GraphemePool, LinkRegistry, optional HitGrid\n- Diff engine (cell-level scan + run grouping)\n- Presenter (ANSI writer, state tracked)\n- Optional simd feature (unsafe isolated)\n\n### ftui-style\n- Visual styling model (TextStyle, CellStyle, Theme)\n- Color downgrade (TrueColor -> 256 -> 16 -> ASCII)\n- Deterministic style merge semantics\n\n### ftui-text\n- Text, Span, Segment (+ markup parser as optional)\n- Width measurement, wrapping, truncation, alignment\n- Caches (LRU widths) and grapheme segmentation\n\n### ftui-layout\n- Rect, constraints, row/col/grid layout, measurement protocol\n\n### ftui-runtime (optional)\n- Bubbletea/Elm-like Program, Model, Cmd, scheduler\n- Deterministic simulator\n\n### ftui-widgets (feature-gated)\n- Component library on kernel + style/text/layout\n\n### ftui-extras (feature-gated)\n- Markdown, syntax highlighting, export, SSH, forms\n\n### ftui-harness (examples)\n- Agent harness reference implementation\n\n### ftui-simd (optional, unsafe allowed)\n- Feature-gated hot loop implementations\n- Strict rules: depends on ftui-render, has scalar fallback\n\n### ftui-pty (test-only)\n- PTY spawning utilities for golden-output harness\n\n## Workspace Cargo.toml\n[workspace]\nmembers = [\n    'ftui',\n    'ftui-core',\n    'ftui-render',\n    'ftui-style',\n    'ftui-text',\n    'ftui-layout',\n    'ftui-runtime',\n    'ftui-widgets',\n    'ftui-extras',\n    'ftui-harness',\n    'ftui-simd',\n    'ftui-pty',\n]\n\n## Safety Policy\nAll crates except ftui-simd: #![forbid(unsafe_code)]\n\n## Acceptance Criteria\n- [ ] Workspace compiles\n- [ ] Each crate has lib.rs with module structure\n- [ ] Dependency graph matches layering (render depends on core, etc.)\n- [ ] forbid(unsafe_code) in place","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:09:47.418333371Z","created_by":"ubuntu","updated_at":"2026-01-31T22:09:47.418333371Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.1","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:09:47.418333371Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.2","title":"Define public Cell API contract","description":"# Define public Cell API contract\n\n## Objective\nDocument and lock the Cell type's public API before implementation. Cell is the most fundamental type - changes here ripple everywhere.\n\n## Cell Contract\n\n### Layout (16 bytes, non-negotiable)\n#[repr(C, align(16))]\npub struct Cell {\n    pub content: CellContent,  // 4 bytes\n    pub fg: PackedRgba,        // 4 bytes\n    pub bg: PackedRgba,        // 4 bytes\n    pub attrs: CellAttrs,      // 4 bytes\n}\n\n### Why 16 Bytes?\n- 4 cells per 64-byte cache line (perfect fit)\n- Single 128-bit SIMD comparison\n- No heap allocation for 99% of cells\n- 24 bytes wastes cache, 32 bytes doubles bandwidth\n\n### CellContent (4 bytes)\nEncoding: [31: type bit][30-0: data]\n- Bit 31 == 0: char (Unicode scalar value)\n- Bit 31 == 1: GraphemeId (pool slot + width)\n\npub struct CellContent(u32);\nimpl CellContent {\n    const EMPTY: Self;\n    fn from_char(c: char) -> Self;\n    fn from_grapheme(id: GraphemeId) -> Self;\n    fn is_grapheme(&self) -> bool;\n    fn width(&self) -> usize;\n}\n\n### PackedRgba (4 bytes)\nLayout: [R:8][G:8][B:8][A:8] native endian\n\npub struct PackedRgba(pub u32);\nimpl PackedRgba {\n    const TRANSPARENT: Self;\n    const BLACK: Self;\n    const WHITE: Self;\n    fn rgb(r: u8, g: u8, b: u8) -> Self;\n    fn rgba(r: u8, g: u8, b: u8, a: u8) -> Self;\n    fn r(&self) -> u8;\n    fn g(&self) -> u8;\n    fn b(&self) -> u8;\n    fn a(&self) -> u8;\n    fn over(self, dst: Self) -> Self;  // Porter-Duff\n    fn with_opacity(self, opacity: f32) -> Self;\n}\n\n### CellAttrs (4 bytes)\nLayout: [31-24: flags][23-0: link_id]\n\npub struct CellAttrs(u32);\nimpl CellAttrs {\n    const NONE: Self;\n    fn new(flags: StyleFlags, link_id: u32) -> Self;\n    fn flags(&self) -> StyleFlags;\n    fn link_id(&self) -> u32;\n    fn with_flags(self, flags: StyleFlags) -> Self;\n    fn with_link(self, link_id: u32) -> Self;\n}\n\n### Cell Methods\nimpl Cell {\n    const CONTINUATION: Self;  // Placeholder for wide chars\n    fn is_continuation(&self) -> bool;\n    fn bits_eq(&self, other: &Self) -> bool;\n    fn width(&self) -> usize;\n}\n\n## Acceptance Criteria\n- [ ] API documented in code comments\n- [ ] Type layout verified with assert_eq!(size_of::<Cell>(), 16)\n- [ ] All methods have doc comments explaining purpose\n- [ ] No pub fields that could break invariants later","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:10:05.152050042Z","created_by":"ubuntu","updated_at":"2026-01-31T22:10:05.152050042Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.2","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:10:05.152050042Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.3","title":"Define public Buffer API contract","description":"# Define public Buffer API contract\n\n## Objective\nDocument and lock the Buffer type's public API. Buffer is the 2D grid that holds Cells.\n\n## Buffer Contract\n\n### Core Structure\npub struct Buffer {\n    width: u16,\n    height: u16,\n    cells: Vec<Cell>,\n    scissor_stack: Vec<Rect>,\n    opacity_stack: Vec<f32>,\n}\n\n### Invariants (MUST ALWAYS HOLD)\n1. cells.len() == width * height\n2. width/height never change after creation\n3. Scissor stack intersection monotonically decreases on push\n4. Opacity stack product stays in [0, 1]\n5. Scissor/opacity stacks always have at least one element\n\n### Constructor\nfn new(width: u16, height: u16) -> Self\n- Initializes cells to Cell::default()\n- Scissor stack starts with full buffer rect\n- Opacity stack starts with 1.0\n\n### Cell Access\nfn get(&self, x: u16, y: u16) -> Option<&Cell>\n- Returns None if out of bounds\n\nfn get_unchecked(&self, x: u16, y: u16) -> &Cell\n- No bounds check, panics on OOB (debug) or UB (release)\n- Only use when bounds verified\n\nfn set(&mut self, x: u16, y: u16, cell: Cell)\n- Respects scissor (skips if outside)\n- Applies opacity stack to cell colors\n- Applies alpha compositing if bg has transparency\n- Handles wide character continuation cells\n\n### Scissor Stack\nfn push_scissor(&mut self, rect: Rect)\n- Computes intersection with current scissor\n- Pushes intersected rect\n\nfn pop_scissor(&mut self)\n- Pops if stack.len() > 1 (preserves base)\n\nfn current_scissor(&self) -> Rect\n- Returns top of stack\n\n### Opacity Stack\nfn push_opacity(&mut self, opacity: f32)\n- Clamps to [0, 1]\n- Pushes current * new\n\nfn pop_opacity(&mut self)\n- Pops if stack.len() > 1\n\nfn current_opacity(&self) -> f32\n- Returns top of stack\n\n### Utilities\nfn clear(&mut self)\n- Fills all cells with Cell::default()\n\nfn cells(&self) -> &[Cell]\n- Raw slice for diffing\n\nfn width(&self) -> u16\nfn height(&self) -> u16\n\n## Frame Contract\nFrame = Buffer + render pass metadata\n\npub struct Frame {\n    pub buffer: Buffer,\n    pub hit_grid: Option<HitGrid>,\n    pub cursor_position: Option<(u16, u16)>,\n    pub cursor_visible: bool,\n}\n\n## Acceptance Criteria\n- [ ] All methods documented\n- [ ] Invariants stated in code comments\n- [ ] Test for each invariant\n- [ ] No UB in safe API","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:10:19.954399597Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:42.521135471Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.3","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:10:19.954399597Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2.3","depends_on_id":"bd-10i.2.2","type":"blocks","created_at":"2026-01-31T22:21:42.521099182Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.4","title":"Define Event types contract","description":"# Define Event types contract\n\n## Objective\nDocument and lock the canonical Event types used throughout ftui.\n\n## Event Enum\npub enum Event {\n    Key(KeyEvent),\n    Mouse(MouseEvent),\n    Resize { width: u16, height: u16 },\n    Paste(PasteEvent),\n    Focus(bool),  // true = gained, false = lost\n    Clipboard(ClipboardEvent),  // optional, feature-gated\n}\n\n## KeyEvent\npub struct KeyEvent {\n    pub code: KeyCode,\n    pub modifiers: Modifiers,\n    pub kind: KeyEventKind,  // Press/Repeat/Release\n}\n\nimpl KeyEvent {\n    fn is_char(&self, c: char) -> bool;\n}\n\n## KeyCode\npub enum KeyCode {\n    Char(char),\n    Enter, Escape, Backspace, Tab, BackTab,\n    Delete, Insert, Home, End,\n    PageUp, PageDown,\n    Up, Down, Left, Right,\n    F(u8),\n    Null,\n}\n\n## KeyEventKind\npub enum KeyEventKind {\n    Press,    // Key pressed (default)\n    Repeat,   // Key held (when available)\n    Release,  // Key released (when available)\n}\n\n## Modifiers\nbitflags! {\n    pub struct Modifiers: u8 {\n        const SHIFT = 0b0001;\n        const ALT   = 0b0010;\n        const CTRL  = 0b0100;\n        const SUPER = 0b1000;\n    }\n}\n\n## MouseEvent\npub struct MouseEvent {\n    pub kind: MouseEventKind,\n    pub x: u16,\n    pub y: u16,\n    pub modifiers: Modifiers,\n}\n\n## MouseEventKind\npub enum MouseEventKind {\n    Down(MouseButton),\n    Up(MouseButton),\n    Drag(MouseButton),\n    Moved,\n    ScrollUp,\n    ScrollDown,\n}\n\n## MouseButton\npub enum MouseButton {\n    Left, Right, Middle,\n}\n\n## PasteEvent\npub struct PasteEvent {\n    pub text: String,\n    pub bracketed: bool,  // True if from bracketed paste mode\n}\n\n## ClipboardEvent (Optional)\npub struct ClipboardEvent {\n    pub content: String,\n    pub source: ClipboardSource,\n}\n\npub enum ClipboardSource { Osc52, Unknown }\n\n## Design Notes\n- Events are Clone + PartialEq + Eq for use in tests\n- Modifiers use bitflags for easy combination\n- Mouse coordinates are 0-indexed (terminal is 1-indexed)\n- KeyEventKind defaults to Press when not available\n\n## Acceptance Criteria\n- [ ] All types documented\n- [ ] Derive Clone, Debug, PartialEq, Eq where appropriate\n- [ ] Event can be converted From Crossterm events","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:10:33.715692497Z","created_by":"ubuntu","updated_at":"2026-01-31T22:10:33.715692497Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.4","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:10:33.715692497Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.5","title":"Define TerminalCapabilities contract","description":"# Define TerminalCapabilities contract\n\n## Objective\nDocument the capability detection model that informs how ftui behaves on different terminals.\n\n## TerminalCapabilities Structure\npub struct TerminalCapabilities {\n    // Color support\n    pub true_color: bool,\n    pub colors_256: bool,\n\n    // Advanced features\n    pub sync_output: bool,       // DEC mode 2026\n    pub osc8_hyperlinks: bool,\n    pub scroll_region: bool,     // DECSTBM\n\n    // Multiplexer detection\n    pub in_tmux: bool,\n    pub in_screen: bool,\n    pub in_zellij: bool,\n\n    // Input features\n    pub kitty_keyboard: bool,\n    pub focus_events: bool,\n    pub bracketed_paste: bool,\n    pub mouse_sgr: bool,\n\n    // Optional features\n    pub osc52_clipboard: bool,   // Best-effort output\n}\n\n## Detection Logic\n\n### Environment Variables\n- COLORTERM: truecolor, 24bit\n- TERM: terminal type (kitty, xterm-256color, etc.)\n- TERM_PROGRAM: iTerm.app, WezTerm, Alacritty, Ghostty\n- NO_COLOR: disable color (de-facto standard)\n- TMUX, STY, ZELLIJ: multiplexer detection\n- KITTY_WINDOW_ID: Kitty detection\n\n### Detection Rules\ntrue_color = \\!NO_COLOR && (COLORTERM contains truecolor/24bit\n             || TERM_PROGRAM in modern terminals)\n\nsync_output = TERM_PROGRAM in [WezTerm, Alacritty, Ghostty]\n              || TERM contains kitty\n\nosc8_hyperlinks = \\!NO_COLOR && TERM_PROGRAM in modern terminals\n\nscroll_region = TERM \\!= dumb (broadly supported)\n\nosc52_clipboard = \\!in_any_mux && TERM \\!= dumb (security restricted)\n\n## Methods\nimpl TerminalCapabilities {\n    fn detect() -> Self;      // From environment\n    fn basic() -> Self;       // Minimal fallback\n    fn in_any_mux(&self) -> bool;  // Any multiplexer?\n}\n\n## Multiplexer Notes\n- TMUX/screen/zellij sit between us and terminal\n- May need passthrough for some features\n- Some features disabled in mux by default\n- WezTerm/Kitty built-in mux doesn't need special handling\n\n## Future: Runtime Probing\nOptional feature-gated probing:\n- Device attribute queries (DA)\n- OSC queries for capabilities\n- Must be bounded with timeouts\n\n## Acceptance Criteria\n- [ ] All fields documented with detection logic\n- [ ] detect() works on common terminals\n- [ ] basic() provides safe fallback\n- [ ] in_any_mux() helper available","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:10:51.010479895Z","created_by":"ubuntu","updated_at":"2026-01-31T22:10:51.010479895Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.5","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:10:51.010479895Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.6","title":"Define TerminalSession lifecycle contract","description":"# Define TerminalSession lifecycle contract\n\n## Objective\nDocument the RAII-based terminal lifecycle management that ensures cleanup even on panic.\n\n## TerminalSession Structure\npub struct TerminalSession<W: Write> {\n    writer: W,\n    raw_mode_active: bool,\n    alt_screen_active: bool,\n    mouse_active: bool,\n    bracketed_paste_active: bool,\n    capabilities: TerminalCapabilities,\n}\n\n## Lifecycle Guarantees\n1. All terminal state changes tracked\n2. Drop restores previous state\n3. Panic hook ensures cleanup\n4. No leaked state on any exit path\n\n## Constructor\nfn new(writer: W) -> io::Result<Self>\n- Detects capabilities\n- Installs panic hook for cleanup\n- Does NOT enter raw mode automatically\n\n## Terminal Modes\nfn enter_raw_mode(&mut self) -> io::Result<()>\n- Enables raw mode (no echo, no line buffering)\n- Tracks state for cleanup\n\nfn enter_alt_screen(&mut self) -> io::Result<()>\n- Switches to alternate screen buffer\n- Emits CSI ? 1049 h\n\nfn enable_mouse(&mut self) -> io::Result<()>\n- Enables SGR mouse mode (1000, 1002, 1006)\n- Tracks for cleanup\n\nfn enable_bracketed_paste(&mut self) -> io::Result<()>\n- Enables bracketed paste mode\n- Emits CSI ? 2004 h\n\nfn enable_focus_events(&mut self) -> io::Result<()>\n- Enables focus tracking\n- Emits CSI ? 1004 h\n\n## Cleanup (Drop)\nimpl<W: Write> Drop for TerminalSession<W> {\n    fn drop(&mut self) {\n        // Disable mouse modes\n        // Disable bracketed paste\n        // Exit alt screen\n        // Reset style (SGR 0)\n        // Show cursor\n        // Restore raw mode (via backend)\n        // Flush\n    }\n}\n\n## Panic Hook\nOn panic, best-effort cleanup:\n- Exit alt screen\n- Show cursor\n- Reset style\n- Disable mouse\n- Disable bracketed paste\n- Flush\n\n## Escape Sequences Reference\n- Alt screen: CSI ? 1049 h/l\n- Mouse: CSI ? 1000/1002/1006 h/l\n- Bracketed paste: CSI ? 2004 h/l\n- Focus events: CSI ? 1004 h/l\n- Show cursor: CSI ? 25 h\n- Reset style: CSI 0 m\n\n## Acceptance Criteria\n- [ ] All state changes tracked\n- [ ] Drop cleans up all active modes\n- [ ] Panic hook installed and tested\n- [ ] PTY test verifies cleanup","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:11:05.056405558Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:42.784922059Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.6","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:11:05.056405558Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2.6","depends_on_id":"bd-10i.2.4","type":"blocks","created_at":"2026-01-31T22:21:42.784885690Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.7","title":"Create ftui facade crate with prelude","description":"# Create ftui facade crate with prelude\n\n## Objective\nCreate the user-facing ftui crate that re-exports stable types and provides ergonomic defaults.\n\n## Purpose\n- Single dependency for most apps\n- Stable API surface\n- Hides internal crate complexity\n- Provides sensible prelude\n\n## Re-exports from Internal Crates\n\n### From ftui-core\n- Event, KeyEvent, MouseEvent, KeyCode, Modifiers\n- TerminalCapabilities, TerminalSession\n- ScreenMode (Inline, AltScreen)\n\n### From ftui-render\n- Cell, CellContent, CellAttrs\n- Buffer, Frame\n- GraphemePool, LinkRegistry\n- Presenter (advanced users)\n\n### From ftui-style\n- Style, TextStyle, CellStyle\n- Color, Theme\n- StyleFlags\n\n### From ftui-text\n- Text, Span\n\n### From ftui-layout\n- Rect, Sides, Measurement\n\n### From ftui-runtime (optional)\n- App, Program, Model, Cmd\n- ProgramSimulator\n\n## Prelude\npub mod prelude {\n    pub use crate::{\n        App, Cmd, Event, Frame, Model,\n        ScreenMode, Style, Result,\n    };\n}\n\n## Ergonomic Builders\n// App builder\nApp::new(model)\n    .screen_mode(ScreenMode::Inline { ui_height: 6 })\n    .run()\n\n// Style builder\nStyle::new().fg(Color::Red).bold()\n\n## Result Type\npub type Result<T> = std::result::Result<T, Error>;\n\n## Error Type\npub enum Error {\n    Io(std::io::Error),\n    Terminal(String),\n    // Add as needed\n}\n\n## Acceptance Criteria\n- [ ] All public types re-exported\n- [ ] Prelude provides common types\n- [ ] App builder compiles (even if not implemented)\n- [ ] Rustdoc renders correctly","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:11:17.978848598Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:42.267890083Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.7","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:11:17.978848598Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2.7","depends_on_id":"bd-10i.2.1","type":"blocks","created_at":"2026-01-31T22:21:42.267859596Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3","title":"Phase 1: Core Render Kernel","description":"# Phase 1: Core Render Kernel\n\n## Purpose\nImplement the sacred kernel types that everything else builds upon. This is the most critical phase - these types must be correct, fast, and stable.\n\n## Core Types to Implement\n1. Cell (16 bytes exactly): content + fg + bg + attrs\n2. CellContent: char or GraphemeId encoding\n3. CellAttrs: flags (8 bits) + link_id (24 bits)\n4. PackedRgba: RGBA as u32 with Porter-Duff blending\n5. GraphemeId + GraphemePool: reference-counted interned complex strings\n6. Buffer: 2D grid with scissor/opacity stacks\n7. Rect, Sides, Measurement primitives\n\n## Technical Constraints\n\n### Cell Layout (The 16-Byte Sweet Spot)\n- 16 bytes = exactly 4 cells per 64-byte cache line\n- Layout: content(4B) + fg(4B) + bg(4B) + attrs(4B)\n- Must use repr(C, align(16))\n- Enables single SIMD comparison for 4 cells\n\n### Why NOT 24 or 32 bytes?\n- 24 bytes: 2.67 cells/line, wastes 16 bytes per line\n- 32 bytes: 2 cells/line, doubles memory bandwidth\n- 16 bytes: Perfect fit, minimal cache misses\n\n### CellContent Encoding\n- Bit 31 == 0: char (Unicode scalar value)\n- Bit 31 == 1: GraphemeId (pool slot in bits 0-23, width in bits 24-30)\n\n### GraphemePool\n- Reference-counted slots for memory efficiency\n- Intern on first use, reuse existing ID if present\n- Free list for slot reuse\n- Refcount management via incref/decref\n\n## Exit Criteria\n- Unit tests pass for all types\n- Scalar bits_eq is correct\n- Buffer invariants enforced (bounds, scissor monotonicity, opacity in [0,1])\n- No unsafe code in this phase","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:05:06.240633451Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:20.563929057Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:05:06.240633451Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3","depends_on_id":"bd-10i.2","type":"blocks","created_at":"2026-01-31T22:21:20.563899021Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.1","title":"Implement CellContent with char/grapheme encoding","description":"# Implement CellContent with char/grapheme encoding\n\n## Objective\nImplement the 4-byte CellContent type that efficiently encodes either a single char or a GraphemeId reference.\n\n## Technical Design\n\n### Encoding Scheme\nBit 31 (type discriminator):\n- 0: Direct char (bits 0-30 contain Unicode scalar value)\n- 1: GraphemeId reference (bits 0-23 = slot, bits 24-30 = width)\n\nThis allows:\n- 99% of cells (ASCII/BMP) to be stored without heap\n- Complex graphemes (emoji, ZWJ sequences) stored in pool\n\n### Implementation\n#[derive(Clone, Copy, PartialEq, Eq)]\n#[repr(transparent)]\npub struct CellContent(u32);\n\nimpl CellContent {\n    pub const EMPTY: Self = Self(0);\n\n    #[inline]\n    pub fn from_char(c: char) -> Self {\n        Self(c as u32)\n    }\n\n    #[inline]\n    pub fn from_grapheme(id: GraphemeId) -> Self {\n        Self(0x8000_0000 | id.0)\n    }\n\n    #[inline]\n    pub fn is_grapheme(&self) -> bool {\n        self.0 & 0x8000_0000 != 0\n    }\n\n    #[inline]\n    pub fn as_char(&self) -> Option<char> {\n        if self.is_grapheme() {\n            None\n        } else {\n            char::from_u32(self.0)\n        }\n    }\n\n    #[inline]\n    pub fn width(&self) -> usize {\n        if self.is_grapheme() {\n            ((self.0 >> 24) & 0x7F) as usize\n        } else if self.0 == 0 {\n            0\n        } else {\n            unicode_width::UnicodeWidthChar::width(\n                char::from_u32(self.0).unwrap_or(' ')\n            ).unwrap_or(1)\n        }\n    }\n}\n\n## GraphemeId Structure\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n#[repr(transparent)]\npub struct GraphemeId(u32);\n\nimpl GraphemeId {\n    #[inline]\n    pub fn new(slot: u32, width: u8) -> Self {\n        debug_assert!(slot < 0x00FF_FFFF);\n        debug_assert!(width < 128);\n        Self((slot & 0x00FF_FFFF) | ((width as u32) << 24))\n    }\n\n    #[inline]\n    pub fn slot(&self) -> usize {\n        (self.0 & 0x00FF_FFFF) as usize\n    }\n\n    #[inline]\n    pub fn width(&self) -> usize {\n        ((self.0 >> 24) & 0x7F) as usize\n    }\n}\n\n## Tests Required\n- [ ] from_char roundtrip for ASCII\n- [ ] from_char roundtrip for BMP chars\n- [ ] from_char roundtrip for supplementary planes\n- [ ] from_grapheme encodes slot and width\n- [ ] width() correct for narrow, wide, emoji\n- [ ] EMPTY has width 0\n- [ ] is_grapheme() discriminates correctly\n\n## Acceptance Criteria\n- [ ] size_of::<CellContent>() == 4\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Inline hints on hot paths","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:11:34.587530319Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:50.998719908Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.1","depends_on_id":"bd-10i.2.2","type":"blocks","created_at":"2026-01-31T22:21:50.998689812Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.1","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:11:34.587530319Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.2","title":"Implement PackedRgba with Porter-Duff blending","description":"# Implement PackedRgba with Porter-Duff blending\n\n## Objective\nImplement the 4-byte packed RGBA color type with efficient alpha compositing.\n\n## Technical Design\n\n### Layout\n[R:8][G:8][B:8][A:8] in native endian as u32\n\n### Why Packed?\n- 4 bytes fits in Cell's 16-byte budget\n- Fast equality comparison (single u32 compare)\n- SIMD-friendly for bulk operations\n\n### Porter-Duff 'Over' Compositing\nResult = src + dst  (1 - src.alpha)\n\nThis is the standard way to composite translucent colors:\n- Fully opaque src (alpha=255): result = src\n- Fully transparent src (alpha=0): result = dst\n- Partial: blend proportionally\n\n### Implementation\n#[derive(Clone, Copy, PartialEq, Eq, Default)]\n#[repr(transparent)]\npub struct PackedRgba(pub u32);\n\nimpl PackedRgba {\n    pub const TRANSPARENT: Self = Self(0);\n    pub const BLACK: Self = Self::rgb(0, 0, 0);\n    pub const WHITE: Self = Self::rgb(255, 255, 255);\n\n    #[inline]\n    pub const fn rgb(r: u8, g: u8, b: u8) -> Self {\n        Self(((r as u32) << 24) | ((g as u32) << 16) \n             | ((b as u32) << 8) | 255)\n    }\n\n    #[inline]\n    pub const fn rgba(r: u8, g: u8, b: u8, a: u8) -> Self {\n        Self(((r as u32) << 24) | ((g as u32) << 16) \n             | ((b as u32) << 8) | (a as u32))\n    }\n\n    // Component accessors\n    #[inline] pub fn r(&self) -> u8 { (self.0 >> 24) as u8 }\n    #[inline] pub fn g(&self) -> u8 { (self.0 >> 16) as u8 }\n    #[inline] pub fn b(&self) -> u8 { (self.0 >> 8) as u8 }\n    #[inline] pub fn a(&self) -> u8 { self.0 as u8 }\n\n    /// Porter-Duff 'over': src over dst\n    #[inline]\n    pub fn over(self, dst: Self) -> Self {\n        let src_a = self.a() as u32;\n        if src_a == 255 { return self; }\n        if src_a == 0 { return dst; }\n\n        let inv_a = 255 - src_a;\n        let r = ((self.r() as u32 * 255) + (dst.r() as u32 * inv_a)) / 255;\n        let g = ((self.g() as u32 * 255) + (dst.g() as u32 * inv_a)) / 255;\n        let b = ((self.b() as u32 * 255) + (dst.b() as u32 * inv_a)) / 255;\n        let a = src_a + ((dst.a() as u32 * inv_a) / 255);\n\n        Self::rgba(r as u8, g as u8, b as u8, a as u8)\n    }\n\n    /// Apply uniform opacity [0.0, 1.0]\n    #[inline]\n    pub fn with_opacity(self, opacity: f32) -> Self {\n        let a = ((self.a() as f32) * opacity.clamp(0.0, 1.0)) as u8;\n        Self((self.0 & 0xFFFF_FF00) | (a as u32))\n    }\n}\n\n## Tests Required\n- [ ] rgb() creates color with alpha=255\n- [ ] rgba() preserves all components\n- [ ] Component accessors round-trip\n- [ ] over() with opaque src returns src\n- [ ] over() with transparent src returns dst\n- [ ] over() blends correctly for 50% alpha\n- [ ] with_opacity() scales alpha correctly\n\n## Acceptance Criteria\n- [ ] size_of::<PackedRgba>() == 4\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Porter-Duff matches reference implementation","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:11:52.455911761Z","created_by":"ubuntu","updated_at":"2026-01-31T22:11:52.455911761Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.2","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:11:52.455911761Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.3","title":"Implement CellAttrs with StyleFlags","description":"# Implement CellAttrs with StyleFlags\n\n## Objective\nImplement the 4-byte packed attributes type that holds style flags and link ID.\n\n## Technical Design\n\n### Layout\n[31-24: flags (8 bits)][23-0: link_id (24 bits)]\n\n### StyleFlags (8 bits)\nUsing bitflags crate for ergonomic flag manipulation:\n- BOLD (1 << 0)\n- DIM (1 << 1)\n- ITALIC (1 << 2)\n- UNDERLINE (1 << 3)\n- BLINK (1 << 4)\n- REVERSE (1 << 5)\n- STRIKETHROUGH (1 << 6)\n- HIDDEN (1 << 7)\n\n### Link ID (24 bits)\n- 0 = no link\n- 1-16777214 = valid link IDs from LinkRegistry\n- Allows ~16 million unique links per frame\n\n### Implementation\nbitflags::bitflags! {\n    #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n    pub struct StyleFlags: u8 {\n        const BOLD          = 0b0000_0001;\n        const DIM           = 0b0000_0010;\n        const ITALIC        = 0b0000_0100;\n        const UNDERLINE     = 0b0000_1000;\n        const BLINK         = 0b0001_0000;\n        const REVERSE       = 0b0010_0000;\n        const STRIKETHROUGH = 0b0100_0000;\n        const HIDDEN        = 0b1000_0000;\n    }\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Default)]\n#[repr(transparent)]\npub struct CellAttrs(u32);\n\nimpl CellAttrs {\n    pub const NONE: Self = Self(0);\n\n    #[inline]\n    pub fn new(flags: StyleFlags, link_id: u32) -> Self {\n        debug_assert!(link_id < 0x00FF_FFFF, 'link_id overflow');\n        Self(((flags.bits() as u32) << 24) | (link_id & 0x00FF_FFFF))\n    }\n\n    #[inline]\n    pub fn flags(&self) -> StyleFlags {\n        StyleFlags::from_bits_truncate((self.0 >> 24) as u8)\n    }\n\n    #[inline]\n    pub fn link_id(&self) -> u32 {\n        self.0 & 0x00FF_FFFF\n    }\n\n    #[inline]\n    pub fn with_flags(self, flags: StyleFlags) -> Self {\n        Self((self.0 & 0x00FF_FFFF) | ((flags.bits() as u32) << 24))\n    }\n\n    #[inline]\n    pub fn with_link(self, link_id: u32) -> Self {\n        Self((self.0 & 0xFF00_0000) | (link_id & 0x00FF_FFFF))\n    }\n\n    #[inline]\n    pub fn has_flag(&self, flag: StyleFlags) -> bool {\n        self.flags().contains(flag)\n    }\n}\n\n## Tests Required\n- [ ] NONE has no flags and link_id = 0\n- [ ] new() stores flags and link_id correctly\n- [ ] flags() retrieves stored flags\n- [ ] link_id() retrieves stored link_id\n- [ ] with_flags() preserves link_id\n- [ ] with_link() preserves flags\n- [ ] Flag combinations work (BOLD | ITALIC)\n- [ ] Boundary: link_id at max value\n\n## Acceptance Criteria\n- [ ] size_of::<CellAttrs>() == 4\n- [ ] All tests pass\n- [ ] bitflags derive works correctly\n- [ ] No unsafe code","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:12:07.470523869Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:51.278476055Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.3","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:12:07.470523869Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.3","depends_on_id":"bd-10i.3.2","type":"blocks","created_at":"2026-01-31T22:21:51.278445687Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.4","title":"Implement Cell struct (16 bytes)","description":"# Implement Cell struct (16 bytes)\n\n## Objective\nImplement the complete Cell struct that combines all components into exactly 16 bytes.\n\n## Technical Design\n\n### Layout\n#[repr(C, align(16))]\npub struct Cell {\n    pub content: CellContent,  // 4 bytes (offset 0)\n    pub fg: PackedRgba,        // 4 bytes (offset 4)\n    pub bg: PackedRgba,        // 4 bytes (offset 8)\n    pub attrs: CellAttrs,      // 4 bytes (offset 12)\n}\n// Total: 16 bytes, aligned to 16-byte boundary\n\n### Why repr(C, align(16))?\n- Predictable memory layout\n- 4 cells per 64-byte cache line\n- Enables SIMD comparison (128-bit)\n- No padding surprises\n\n### Special Cells\n- CONTINUATION: Placeholder for second column of wide chars\n  - content = 0xFFFF_FFFF (invalid Unicode)\n  - Used when wide char occupies 2 cells\n\n### Implementation\nimpl Default for Cell {\n    fn default() -> Self {\n        Self {\n            content: CellContent::EMPTY,\n            fg: PackedRgba::WHITE,\n            bg: PackedRgba::TRANSPARENT,\n            attrs: CellAttrs::NONE,\n        }\n    }\n}\n\nimpl Cell {\n    pub const CONTINUATION: Self = Self {\n        content: CellContent(0xFFFF_FFFF),\n        fg: PackedRgba::TRANSPARENT,\n        bg: PackedRgba::TRANSPARENT,\n        attrs: CellAttrs::NONE,\n    };\n\n    #[inline]\n    pub fn is_continuation(&self) -> bool {\n        self.content.0 == 0xFFFF_FFFF\n    }\n\n    /// Bitwise equality (fast path for diffing)\n    #[inline]\n    pub fn bits_eq(&self, other: &Self) -> bool {\n        self.content == other.content &&\n        self.fg == other.fg &&\n        self.bg == other.bg &&\n        self.attrs == other.attrs\n    }\n\n    #[inline]\n    pub fn width(&self) -> usize {\n        self.content.width()\n    }\n\n    // Builder methods\n    pub fn char(c: char) -> Self {\n        Self {\n            content: CellContent::from_char(c),\n            ..Default::default()\n        }\n    }\n\n    pub fn fg(mut self, color: PackedRgba) -> Self {\n        self.fg = color;\n        self\n    }\n\n    pub fn bg(mut self, color: PackedRgba) -> Self {\n        self.bg = color;\n        self\n    }\n\n    pub fn attrs(mut self, attrs: CellAttrs) -> Self {\n        self.attrs = attrs;\n        self\n    }\n}\n\nimpl PartialEq for Cell {\n    fn eq(&self, other: &Self) -> bool {\n        self.bits_eq(other)\n    }\n}\n\nimpl Eq for Cell {}\n\n## Tests Required\n- [ ] size_of::<Cell>() == 16\n- [ ] align_of::<Cell>() == 16\n- [ ] Default produces expected values\n- [ ] CONTINUATION is distinguishable\n- [ ] bits_eq matches PartialEq\n- [ ] Builder methods work correctly\n- [ ] width() delegates to content\n\n## Acceptance Criteria\n- [ ] Exact 16-byte size verified\n- [ ] 16-byte alignment verified\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Performance: bits_eq in < 1ns","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:12:22.103820544Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:51.806317486Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.4","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:12:22.103820544Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.4","depends_on_id":"bd-10i.3.1","type":"blocks","created_at":"2026-01-31T22:21:51.553544228Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.4","depends_on_id":"bd-10i.3.3","type":"blocks","created_at":"2026-01-31T22:21:51.806289113Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.5","title":"Implement GraphemePool with refcounting","description":"# Implement GraphemePool with refcounting\n\n## Objective\nImplement the reference-counted pool for complex grapheme clusters (emoji, ZWJ sequences).\n\n## Why GraphemePool?\nMost cells are simple ASCII or BMP characters that fit in CellContent's 4 bytes directly. But some graphemes (emoji with skin tone, ZWJ sequences like family emoji) require multiple Unicode codepoints and variable-length strings.\n\nThe pool:\n- Stores these complex strings once\n- Returns a compact GraphemeId (4 bytes)\n- Reference counts for memory management\n- Reuses slots from free list\n\n## Technical Design\n\n### Slot Structure\nstruct GraphemeSlot {\n    text: String,      // The actual grapheme string\n    width: u8,         // Display width (0-127)\n    refcount: u32,     // Reference count\n}\n\n### Pool Structure\npub struct GraphemePool {\n    strings: Vec<Option<GraphemeSlot>>,  // Slot storage\n    lookup: HashMap<String, GraphemeId>, // Fast dedup\n    free_list: Vec<u32>,                 // Reusable slots\n}\n\n### Implementation\nimpl GraphemePool {\n    pub fn new() -> Self {\n        Self {\n            strings: Vec::new(),\n            lookup: HashMap::new(),\n            free_list: Vec::new(),\n        }\n    }\n\n    /// Intern a grapheme, returning existing ID if present\n    pub fn intern(&mut self, s: &str) -> GraphemeId {\n        // Check if already interned\n        if let Some(&id) = self.lookup.get(s) {\n            self.incref(id);\n            return id;\n        }\n\n        // Calculate display width\n        let width = unicode_width::UnicodeWidthStr::width(s)\n            .min(127) as u8;\n\n        // Find or create slot\n        let slot_idx = self.free_list.pop().unwrap_or_else(|| {\n            let idx = self.strings.len() as u32;\n            self.strings.push(None);\n            idx\n        });\n\n        let id = GraphemeId::new(slot_idx, width);\n        self.strings[slot_idx as usize] = Some(GraphemeSlot {\n            text: s.to_string(),\n            width,\n            refcount: 1,\n        });\n        self.lookup.insert(s.to_string(), id);\n        id\n    }\n\n    /// Get string for ID\n    pub fn get(&self, id: GraphemeId) -> Option<&str> {\n        self.strings.get(id.slot())\n            .and_then(|slot| slot.as_ref())\n            .map(|s| s.text.as_str())\n    }\n\n    /// Increment refcount\n    fn incref(&mut self, id: GraphemeId) {\n        if let Some(Some(slot)) = self.strings.get_mut(id.slot()) {\n            slot.refcount = slot.refcount.saturating_add(1);\n        }\n    }\n\n    /// Decrement refcount, freeing if zero\n    pub fn decref(&mut self, id: GraphemeId) {\n        let slot_idx = id.slot();\n        if let Some(Some(slot)) = self.strings.get_mut(slot_idx) {\n            slot.refcount = slot.refcount.saturating_sub(1);\n            if slot.refcount == 0 {\n                self.lookup.remove(&slot.text);\n                self.strings[slot_idx] = None;\n                self.free_list.push(slot_idx as u32);\n            }\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.strings.iter().filter(|s| s.is_some()).count()\n    }\n}\n\n## Invariants\n- slot.refcount > 0 implies slot is valid\n- GraphemeId only created via pool.intern()\n- lookup and strings are consistent\n- Free list contains only None slots\n\n## Tests Required\n- [ ] intern() returns same ID for same string\n- [ ] intern() increments refcount on reuse\n- [ ] get() retrieves correct string\n- [ ] decref() frees at refcount 0\n- [ ] Free list reuses slots\n- [ ] Width calculation correct for emoji\n- [ ] ZWJ sequences handled\n\n## Acceptance Criteria\n- [ ] All invariants maintained\n- [ ] All tests pass\n- [ ] Intern hit: < 100ns\n- [ ] Intern miss: < 1us","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:12:41.853594562Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:52.050855468Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.5","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:12:41.853594562Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.5","depends_on_id":"bd-10i.3.1","type":"blocks","created_at":"2026-01-31T22:21:52.050825272Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.6","title":"Implement Buffer with scissor/opacity stacks","description":"# Implement Buffer with scissor/opacity stacks\n\n## Objective\nImplement the 2D cell grid with support for scissor (clipping) and opacity stacks for compositing.\n\n## Technical Design\n\n### Structure\npub struct Buffer {\n    width: u16,\n    height: u16,\n    cells: Vec<Cell>,\n    scissor_stack: Vec<Rect>,\n    opacity_stack: Vec<f32>,\n}\n\n### Invariants\n1. cells.len() == width * height (always)\n2. width/height immutable after creation\n3. Scissor intersection monotonically decreases on push\n4. Opacity product stays in [0, 1]\n5. Both stacks always have at least one element\n\n### Implementation\nimpl Buffer {\n    pub fn new(width: u16, height: u16) -> Self {\n        let size = (width as usize) * (height as usize);\n        Self {\n            width,\n            height,\n            cells: vec![Cell::default(); size],\n            scissor_stack: vec![Rect::new(0, 0, width, height)],\n            opacity_stack: vec![1.0],\n        }\n    }\n\n    // Accessors\n    #[inline]\n    pub fn width(&self) -> u16 { self.width }\n    \n    #[inline]\n    pub fn height(&self) -> u16 { self.height }\n\n    // Cell access with bounds check\n    #[inline]\n    pub fn get(&self, x: u16, y: u16) -> Option<&Cell> {\n        if x < self.width && y < self.height {\n            Some(&self.cells[self.index(x, y)])\n        } else {\n            None\n        }\n    }\n\n    // Unchecked access (for diffing hot path)\n    #[inline]\n    pub fn get_unchecked(&self, x: u16, y: u16) -> &Cell {\n        &self.cells[self.index(x, y)]\n    }\n\n    #[inline]\n    fn index(&self, x: u16, y: u16) -> usize {\n        (y as usize) * (self.width as usize) + (x as usize)\n    }\n\n    // Cell mutation with scissor/opacity\n    pub fn set(&mut self, x: u16, y: u16, mut cell: Cell) {\n        if !self.in_scissor(x, y) { return; }\n\n        // Apply opacity\n        let opacity = self.current_opacity();\n        if opacity < 1.0 {\n            cell.fg = cell.fg.with_opacity(opacity);\n            cell.bg = cell.bg.with_opacity(opacity);\n        }\n\n        // Alpha composite if bg transparent\n        if cell.bg.a() < 255 {\n            if let Some(existing) = self.get(x, y) {\n                cell.bg = cell.bg.over(existing.bg);\n            }\n        }\n\n        let idx = self.index(x, y);\n        self.cells[idx] = cell;\n\n        // Wide char continuation\n        if cell.width() == 2 && x + 1 < self.width {\n            self.cells[idx + 1] = Cell::CONTINUATION;\n        }\n    }\n\n    // Scissor stack\n    pub fn push_scissor(&mut self, rect: Rect) {\n        let current = self.current_scissor();\n        self.scissor_stack.push(current.intersection(&rect));\n    }\n\n    pub fn pop_scissor(&mut self) {\n        if self.scissor_stack.len() > 1 {\n            self.scissor_stack.pop();\n        }\n    }\n\n    fn current_scissor(&self) -> Rect {\n        *self.scissor_stack.last().unwrap()\n    }\n\n    fn in_scissor(&self, x: u16, y: u16) -> bool {\n        self.current_scissor().contains(x, y)\n    }\n\n    // Opacity stack\n    pub fn push_opacity(&mut self, opacity: f32) {\n        let current = self.current_opacity();\n        self.opacity_stack.push(current * opacity.clamp(0.0, 1.0));\n    }\n\n    pub fn pop_opacity(&mut self) {\n        if self.opacity_stack.len() > 1 {\n            self.opacity_stack.pop();\n        }\n    }\n\n    fn current_opacity(&self) -> f32 {\n        *self.opacity_stack.last().unwrap()\n    }\n\n    // Utilities\n    pub fn clear(&mut self) {\n        self.cells.fill(Cell::default());\n    }\n\n    pub fn cells(&self) -> &[Cell] {\n        &self.cells\n    }\n}\n\n## Tests Required\n- [ ] new() creates correct size\n- [ ] get() returns None for OOB\n- [ ] set() respects scissor\n- [ ] push_scissor intersects correctly\n- [ ] pop_scissor preserves base\n- [ ] Opacity multiplies correctly\n- [ ] Wide chars create continuation\n- [ ] clear() resets all cells\n\n## Acceptance Criteria\n- [ ] All invariants tested\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Memory: exactly width*height*16 bytes for cells","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:13:01.324377225Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:52.811032251Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.6","depends_on_id":"bd-10i.2.3","type":"blocks","created_at":"2026-01-31T22:21:52.810995362Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.6","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:13:01.324377225Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.6","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T22:21:52.290284214Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.6","depends_on_id":"bd-10i.3.5","type":"blocks","created_at":"2026-01-31T22:21:52.547476017Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.7","title":"Implement Rect, Sides, Measurement primitives","description":"# Implement Rect, Sides, Measurement primitives\n\n## Objective\nImplement the layout primitives used throughout ftui.\n\n## Rect (Rectangle)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub struct Rect {\n    pub x: u16,\n    pub y: u16,\n    pub width: u16,\n    pub height: u16,\n}\n\nimpl Rect {\n    pub fn new(x: u16, y: u16, width: u16, height: u16) -> Self {\n        Self { x, y, width, height }\n    }\n\n    pub fn contains(&self, x: u16, y: u16) -> bool {\n        x >= self.x && x < self.x + self.width &&\n        y >= self.y && y < self.y + self.height\n    }\n\n    pub fn intersection(&self, other: &Self) -> Self {\n        let x = self.x.max(other.x);\n        let y = self.y.max(other.y);\n        let right = (self.x + self.width).min(other.x + other.width);\n        let bottom = (self.y + self.height).min(other.y + other.height);\n\n        if right > x && bottom > y {\n            Self::new(x, y, right - x, bottom - y)\n        } else {\n            Self::default()  // Empty rect\n        }\n    }\n\n    pub fn inner(&self, margin: Sides) -> Self {\n        Self::new(\n            self.x + margin.left,\n            self.y + margin.top,\n            self.width.saturating_sub(margin.left + margin.right),\n            self.height.saturating_sub(margin.top + margin.bottom),\n        )\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.width == 0 || self.height == 0\n    }\n\n    pub fn area(&self) -> u32 {\n        self.width as u32 * self.height as u32\n    }\n}\n\n## Sides (Padding/Margin)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub struct Sides {\n    pub top: u16,\n    pub right: u16,\n    pub bottom: u16,\n    pub left: u16,\n}\n\nimpl Sides {\n    pub fn all(v: u16) -> Self {\n        Self { top: v, right: v, bottom: v, left: v }\n    }\n\n    pub fn horizontal(v: u16) -> Self {\n        Self { top: 0, right: v, bottom: 0, left: v }\n    }\n\n    pub fn vertical(v: u16) -> Self {\n        Self { top: v, right: 0, bottom: v, left: 0 }\n    }\n\n    pub fn horizontal_sum(&self) -> u16 {\n        self.left + self.right\n    }\n\n    pub fn vertical_sum(&self) -> u16 {\n        self.top + self.bottom\n    }\n}\n\n// CSS-like tuple conversions\nimpl From<u16> for Sides {\n    fn from(v: u16) -> Self { Self::all(v) }\n}\n\nimpl From<(u16, u16)> for Sides {\n    fn from((v, h): (u16, u16)) -> Self {\n        Self { top: v, right: h, bottom: v, left: h }\n    }\n}\n\nimpl From<(u16, u16, u16, u16)> for Sides {\n    fn from((t, r, b, l): (u16, u16, u16, u16)) -> Self {\n        Self { top: t, right: r, bottom: b, left: l }\n    }\n}\n\n## Measurement (for layout negotiation)\n#[derive(Debug, Clone, Copy, Default)]\npub struct Measurement {\n    pub min_width: u16,\n    pub min_height: u16,\n    pub max_width: Option<u16>,\n    pub max_height: Option<u16>,\n}\n\nimpl Measurement {\n    pub fn fixed(width: u16, height: u16) -> Self {\n        Self {\n            min_width: width,\n            min_height: height,\n            max_width: Some(width),\n            max_height: Some(height),\n        }\n    }\n\n    pub fn flexible(min_w: u16, min_h: u16) -> Self {\n        Self {\n            min_width: min_w,\n            min_height: min_h,\n            max_width: None,\n            max_height: None,\n        }\n    }\n}\n\n## Tests Required\n- [ ] Rect::contains for corners and edges\n- [ ] Rect::intersection produces correct result\n- [ ] Rect::intersection with no overlap returns empty\n- [ ] Rect::inner reduces correctly\n- [ ] Sides::all, horizontal, vertical\n- [ ] Sides tuple conversions\n- [ ] Measurement::fixed constraints\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Ergonomic tuple conversions work","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:13:17.121141650Z","created_by":"ubuntu","updated_at":"2026-01-31T22:13:17.121141650Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.7","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:13:17.121141650Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4","title":"Phase 2: Diff + Presenter (Near-minimal ANSI)","description":"# Phase 2: Diff + Presenter (Near-minimal ANSI)\n\n## Purpose\nImplement the diff engine and ANSI presenter that transform buffer changes into minimal terminal output. This is where the 'zero-flicker' promise is delivered.\n\n## Components\n\n### BufferDiff\n- Compute diff between old and new buffers\n- Row-major scan for cache efficiency\n- Output as list of changed positions\n- Convert to ChangeRuns for efficient emission\n\n### ChangeRun\n- Contiguous run of changed cells on a single row\n- Allows single cursor move per run instead of per-cell\n\n### Presenter (State-Tracked ANSI Writer)\n- Tracks current style, link, cursor position\n- Only emits changes from tracked state\n- Uses BufWriter with 64KB buffer\n- Supports synchronized output (DEC mode 2026)\n\n## Key Decisions (from ADRs)\n\n### Style Emission Strategy\n- v1 default: Reset+apply (SGR 0 then re-apply)\n- Simple and correct, though more bytes\n- Incremental/hybrid behind feature flag until benchmarks justify\n\n### Synchronized Output\n- Use CSI ? 2026 h/l when available\n- Reduces flicker by batching updates\n- Must work without it (graceful degradation)\n\n### Run Grouping\n- Emit changes in row-major runs\n- Single cursor move per run\n- Sequential character emission within runs (cursor advances naturally)\n\n## Exit Criteria\n- Single write per frame achieved\n- Run grouping works correctly\n- Inline demo shows no flicker on supported terminals\n- Style state cannot leak across runs (terminal-model tests)\n- Links (OSC 8) cannot remain open after present/exit","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:05:21.404504792Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:20.799685524Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:05:21.404504792Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T22:21:20.799655478Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4.1","title":"Implement BufferDiff with row-major scan","description":"# Implement BufferDiff with row-major scan\n\n## Objective\nImplement the diff engine that computes changed cells between two buffers efficiently.\n\n## Why Diffing Matters\nThe fundamental theorem of terminal UI: produce the minimal byte stream to transform current grid to desired grid. Diffing identifies what actually changed so we don't re-emit unchanged cells.\n\n## Technical Design\n\n### Structure\npub struct BufferDiff {\n    changes: Vec<(u16, u16)>,  // (x, y) of changed cells\n}\n\n### Algorithm\nRow-major scan for cache efficiency:\n1. Iterate y from 0 to height\n2. Iterate x from 0 to width\n3. Compare old[x,y] with new[x,y] using bits_eq\n4. Record position if different\n\nRow-major ensures sequential memory access:\n- Cells are stored row-by-row\n- Prefetcher can anticipate next access\n- 4 cells per cache line means 4 comparisons per line load\n\n### Implementation\nimpl BufferDiff {\n    pub fn compute(old: &Buffer, new: &Buffer) -> Self {\n        debug_assert_eq!(old.width(), new.width());\n        debug_assert_eq!(old.height(), new.height());\n\n        let mut changes = Vec::new();\n        let width = old.width();\n        let height = old.height();\n\n        // Row-major scan for cache efficiency\n        for y in 0..height {\n            for x in 0..width {\n                let old_cell = old.get_unchecked(x, y);\n                let new_cell = new.get_unchecked(x, y);\n                if !old_cell.bits_eq(new_cell) {\n                    changes.push((x, y));\n                }\n            }\n        }\n\n        Self { changes }\n    }\n\n    pub fn len(&self) -> usize {\n        self.changes.len()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.changes.is_empty()\n    }\n\n    pub fn changes(&self) -> &[(u16, u16)] {\n        &self.changes\n    }\n}\n\n### ChangeRun (for efficient emission)\nConvert point changes into contiguous runs:\n\npub struct ChangeRun {\n    pub y: u16,    // Row\n    pub x0: u16,   // Start column\n    pub x1: u16,   // End column (inclusive)\n}\n\nimpl BufferDiff {\n    pub fn runs(&self, _width: u16) -> Vec<ChangeRun> {\n        // Sort by (y, x) - already sorted from scan\n        // Coalesce consecutive x positions on same row\n\n        let mut runs = Vec::new();\n        if self.changes.is_empty() { return runs; }\n\n        let mut sorted = self.changes.clone();\n        sorted.sort_by_key(|(x, y)| (*y, *x));\n\n        let mut i = 0;\n        while i < sorted.len() {\n            let (x0, y) = sorted[i];\n            let mut x1 = x0;\n            i += 1;\n\n            // Coalesce consecutive x\n            while i < sorted.len() {\n                let (x, yy) = sorted[i];\n                if yy != y || x != x1 + 1 { break; }\n                x1 = x;\n                i += 1;\n            }\n\n            runs.push(ChangeRun { y, x0, x1 });\n        }\n\n        runs\n    }\n}\n\n## Performance Target\n- 80x24, full diff: < 500us\n- Typical 5% change: proportionally faster\n\n## Tests Required\n- [ ] Empty diff when buffers identical\n- [ ] Single cell change detected\n- [ ] Multiple scattered changes detected\n- [ ] runs() coalesces adjacent cells\n- [ ] runs() handles gaps correctly\n- [ ] Performance meets target\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] No unsafe code in default build\n- [ ] Performance: < 500us for 80x24","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:13:35.587846708Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:59.480036868Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4.1","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:21:59.480007032Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.1","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:13:35.587846708Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4.2","title":"Implement LinkRegistry for OSC 8 hyperlinks","description":"# Implement LinkRegistry for OSC 8 hyperlinks\n\n## Objective\nImplement URL storage and ID management for OSC 8 hyperlinks.\n\n## Background: OSC 8 Hyperlinks\nModern terminals support clickable hyperlinks via OSC 8:\n- Start link: ESC ] 8 ; ; URL ESC \\\\\n- End link: ESC ] 8 ; ; ESC \\\\\n\nMultiple cells can share the same link by using the same link ID. The registry deduplicates URLs and manages IDs.\n\n## Technical Design\n\n### Structure\npub struct LinkRegistry {\n    links: Vec<Option<String>>,      // ID -> URL mapping\n    lookup: HashMap<String, u32>,    // URL -> ID for dedup\n    free_list: Vec<u32>,            // Reusable IDs\n}\n\n### Implementation\nimpl LinkRegistry {\n    pub fn new() -> Self {\n        Self {\n            links: Vec::new(),\n            lookup: HashMap::new(),\n            free_list: Vec::new(),\n        }\n    }\n\n    /// Register a URL, returning existing ID if present\n    pub fn register(&mut self, url: &str) -> u32 {\n        // Check for existing\n        if let Some(&id) = self.lookup.get(url) {\n            return id;\n        }\n\n        // Allocate new ID\n        let id = self.free_list.pop().unwrap_or_else(|| {\n            let idx = self.links.len() as u32;\n            self.links.push(None);\n            idx\n        });\n\n        self.links[id as usize] = Some(url.to_string());\n        self.lookup.insert(url.to_string(), id);\n        id\n    }\n\n    /// Get URL for ID\n    pub fn get(&self, id: u32) -> Option<&str> {\n        self.links.get(id as usize)\n            .and_then(|slot| slot.as_ref())\n            .map(|s| s.as_str())\n    }\n\n    /// Unregister a link (for cleanup)\n    pub fn unregister(&mut self, id: u32) {\n        if let Some(Some(url)) = self.links.get(id as usize).cloned() {\n            self.lookup.remove(&url);\n            self.links[id as usize] = None;\n            self.free_list.push(id);\n        }\n    }\n\n    /// Check if ID is valid\n    pub fn contains(&self, id: u32) -> bool {\n        self.links.get(id as usize)\n            .map(|slot| slot.is_some())\n            .unwrap_or(false)\n    }\n\n    pub fn len(&self) -> usize {\n        self.links.iter().filter(|l| l.is_some()).count()\n    }\n}\n\n## Link Lifecycle in Rendering\n1. When drawing a cell with a link:\n   - Register URL with registry\n   - Store link_id in CellAttrs\n\n2. When presenting:\n   - Check if link_id changed from tracked state\n   - If changed, emit OSC 8 open/close sequences\n\n3. After frame:\n   - Links not used can be unregistered (optional GC)\n\n## Tests Required\n- [ ] register() returns same ID for same URL\n- [ ] register() returns different IDs for different URLs\n- [ ] get() retrieves correct URL\n- [ ] unregister() frees slot\n- [ ] Free list reuses IDs\n- [ ] contains() correct for valid/invalid IDs\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Deduplication works correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:13:53.031307640Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:59.746043980Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4.2","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T22:21:59.746016368Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.2","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:13:53.031307640Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4.3","title":"Implement Presenter with state-tracked ANSI emission","description":"# Implement Presenter with state-tracked ANSI emission\n\n## Objective\nImplement the core ANSI emitter that transforms buffer diffs into terminal output with minimal bytes.\n\n## Technical Design\n\n### State Tracking\nTrack current terminal state to avoid redundant sequences:\n- current_style: Option<CellStyle> (fg, bg, attrs)\n- current_link: Option<u32> (link ID)\n- cursor_x, cursor_y: u16 (cursor position)\n\n### Structure\npub struct Presenter<W: Write> {\n    writer: BufWriter<W>,    // 64KB buffer\n    current_style: Option<CellStyle>,\n    current_link: Option<u32>,\n    cursor_x: u16,\n    cursor_y: u16,\n    capabilities: TerminalCapabilities,\n}\n\n#[derive(Clone, Copy, PartialEq, Eq)]\nstruct CellStyle {\n    fg: PackedRgba,\n    bg: PackedRgba,\n    attrs: StyleFlags,\n}\n\n### Implementation\n\nimpl<W: Write> Presenter<W> {\n    pub fn new(writer: W, capabilities: TerminalCapabilities) -> Self {\n        Self {\n            writer: BufWriter::with_capacity(64 * 1024, writer),\n            current_style: None,\n            current_link: None,\n            cursor_x: 0,\n            cursor_y: 0,\n            capabilities,\n        }\n    }\n\n    /// Present a frame using diff\n    pub fn present(\n        &mut self,\n        buffer: &Buffer,\n        diff: &BufferDiff,\n        pool: &GraphemePool,\n        links: &LinkRegistry,\n    ) -> io::Result<()> {\n        // Begin synchronized output\n        if self.capabilities.sync_output {\n            self.writer.write_all(b\"\\x1b[?2026h\")?;\n        }\n\n        // Emit diff using run grouping\n        self.emit_diff(buffer, diff, pool, links)?;\n\n        // Reset style at end (clean state)\n        self.writer.write_all(b\"\\x1b[0m\")?;\n        self.current_style = None;\n\n        // Close any open link\n        if self.current_link.is_some() {\n            self.writer.write_all(b\"\\x1b]8;;\\x1b\\\\\")?;\n            self.current_link = None;\n        }\n\n        // End synchronized output\n        if self.capabilities.sync_output {\n            self.writer.write_all(b\"\\x1b[?2026l\")?;\n        }\n\n        self.writer.flush()\n    }\n\n    fn emit_diff(...) -> io::Result<()> {\n        for run in diff.runs(buffer.width()) {\n            // Single cursor move per run\n            self.move_cursor_to(run.x0, run.y)?;\n\n            // Emit cells (cursor advances naturally)\n            for x in run.x0..=run.x1 {\n                let cell = buffer.get_unchecked(x, run.y);\n                self.emit_cell(cell, pool, links)?;\n            }\n        }\n        Ok(())\n    }\n\n    fn emit_cell(...) -> io::Result<()> {\n        if cell.is_continuation() { return Ok(()); }\n\n        self.emit_style_changes(cell)?;\n        self.emit_link_changes(cell, links)?;\n        self.emit_content(cell, pool)?;\n\n        self.cursor_x += cell.width() as u16;\n        Ok(())\n    }\n\n    fn emit_style_changes(&mut self, cell: &Cell) -> io::Result<()> {\n        // v1: Reset+apply strategy (per ADR-002)\n        // Emit SGR 0 then apply all attributes\n        // Optimization: skip if style unchanged\n    }\n\n    fn emit_link_changes(&mut self, cell: &Cell, registry: &LinkRegistry) -> io::Result<()> {\n        // Open/close OSC 8 links as needed\n    }\n\n    fn emit_content(&mut self, cell: &Cell, pool: &GraphemePool) -> io::Result<()> {\n        // Emit char or grapheme from pool\n    }\n\n    fn move_cursor_to(&mut self, x: u16, y: u16) -> io::Result<()> {\n        if self.cursor_x == x && self.cursor_y == y { return Ok(()); }\n        write!(self.writer, \"\\x1b[{};{}H\", y + 1, x + 1)?;\n        self.cursor_x = x;\n        self.cursor_y = y;\n        Ok(())\n    }\n}\n\n## ANSI Sequences Reference\n- Cursor position: CSI row ; col H (1-indexed)\n- SGR reset: CSI 0 m\n- SGR attributes: CSI n ; n ; ... m\n- True color fg: CSI 38 ; 2 ; r ; g ; b m\n- True color bg: CSI 48 ; 2 ; r ; g ; b m\n- OSC 8 open: OSC 8 ; ; url ST\n- OSC 8 close: OSC 8 ; ; ST\n- Sync begin: CSI ? 2026 h\n- Sync end: CSI ? 2026 l\n\n## Tests Required\n- [ ] present() produces valid ANSI\n- [ ] Style tracking avoids redundant SGR\n- [ ] Link tracking opens/closes correctly\n- [ ] Cursor moves are minimized via runs\n- [ ] Empty diff produces no cell output\n- [ ] Sync output wrapped when supported\n\n## Acceptance Criteria\n- [ ] Terminal-model tests pass\n- [ ] PTY tests show correct output\n- [ ] Single write per frame (buffered)\n- [ ] No style/link leaks after present","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:14:16.508100183Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:00.259747605Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4.3","depends_on_id":"bd-10i.2.5","type":"blocks","created_at":"2026-01-31T22:22:00.259710385Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.3","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:14:16.508100183Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.3","depends_on_id":"bd-10i.4.1","type":"blocks","created_at":"2026-01-31T22:21:59.992602219Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4.4","title":"Implement TerminalCapabilities detection","description":"# Implement TerminalCapabilities detection\n\n## Objective\nImplement environment-based capability detection for adapting to different terminals.\n\n## Detection Logic Summary\n\n### Color Support\ntrue_color = \\!NO_COLOR && (\n    COLORTERM in [truecolor, 24bit] ||\n    TERM contains [kitty, wezterm, alacritty, ghostty] ||\n    TERM_PROGRAM in [iTerm.app, WezTerm, Alacritty, Ghostty]\n)\n\ncolors_256 = true_color || TERM contains 256color\n\n### Synchronized Output (DEC 2026)\nsync_output = TERM_PROGRAM in [WezTerm, Alacritty, Ghostty] ||\n              TERM contains kitty ||\n              KITTY_WINDOW_ID set\n\n### OSC 8 Hyperlinks\nosc8_hyperlinks = \\!NO_COLOR && (\n    TERM_PROGRAM in [iTerm.app, WezTerm, Ghostty] ||\n    TERM contains kitty\n)\n\n### Multiplexer Detection\nin_tmux = TMUX env var set\nin_screen = STY env var set\nin_zellij = ZELLIJ env var set\n\n### Input Features\nkitty_keyboard = TERM contains kitty || KITTY_WINDOW_ID set\nfocus_events = true (widely supported)\nbracketed_paste = true (widely supported)\nmouse_sgr = true (widely supported)\n\n### Scroll Region (DECSTBM)\nscroll_region = TERM \\!= dumb\n\n### OSC 52 Clipboard\nosc52_clipboard = \\!in_any_mux && TERM \\!= dumb\n(Security restricted in mux environments)\n\n## Environment Variables Used\n- NO_COLOR: Disable color (de-facto standard)\n- COLORTERM: Color capability hint\n- TERM: Terminal type\n- TERM_PROGRAM: Terminal application name\n- TMUX: tmux socket path (indicates tmux)\n- STY: screen session name (indicates screen)\n- ZELLIJ: Zellij session\n- KITTY_WINDOW_ID: Kitty window identifier\n\n## Implementation\nimpl TerminalCapabilities {\n    pub fn detect() -> Self {\n        let no_color = std::env::var('NO_COLOR').is_ok();\n        let colorterm = std::env::var('COLORTERM').unwrap_or_default();\n        let term = std::env::var('TERM').unwrap_or_default();\n        let term_program = std::env::var('TERM_PROGRAM').unwrap_or_default();\n\n        let in_tmux = std::env::var('TMUX').is_ok();\n        let in_screen = std::env::var('STY').is_ok();\n        let in_zellij = std::env::var('ZELLIJ').is_ok();\n\n        // ... detection logic ...\n\n        Self { ... }\n    }\n\n    pub fn basic() -> Self {\n        // Minimal fallback: no advanced features\n    }\n\n    pub fn in_any_mux(&self) -> bool {\n        self.in_tmux || self.in_screen || self.in_zellij\n    }\n}\n\n## Tests Required\n- [ ] NO_COLOR disables color features\n- [ ] COLORTERM=truecolor enables true_color\n- [ ] Known terminals detected correctly\n- [ ] Multiplexer detection works\n- [ ] basic() returns conservative defaults\n\n## Acceptance Criteria\n- [ ] All common terminals detected correctly\n- [ ] Conservative fallbacks for unknown\n- [ ] Tests cover major scenarios","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:14:35.007795448Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:00.519638003Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4.4","depends_on_id":"bd-10i.2.5","type":"blocks","created_at":"2026-01-31T22:22:00.519607715Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.4","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:14:35.007795448Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.5","title":"Phase 3: Input System","description":"# Phase 3: Input System\n\n## Purpose\nImplement robust input parsing that handles all terminal input sequences while protecting against DoS attacks.\n\n## Event Types\n- Key(KeyEvent): code, modifiers, kind (Press/Repeat/Release)\n- Mouse(MouseEvent): kind, x, y, modifiers\n- Resize { width, height }\n- Paste(PasteEvent): text, bracketed flag\n- Focus(bool): gained/lost\n\n## Parser State Machine\nStates: Ground, Escape, Csi, CsiParam, Osc, Dcs, Ss3\n\n### DoS Protection (CRITICAL)\n- max_csi_len: 256 bytes (prevents CSI bomb)\n- max_osc_len: 4096 bytes\n- max_dcs_len: 4096 bytes\n- max_paste_len: 1MB (configurable)\n- Parser must remain linear time for worst-case inputs\n- No panics on malformed sequences\n\n## Protocols to Support\n1. Standard ASCII + UTF-8\n2. CSI sequences (arrows, function keys, modifiers)\n3. SS3 sequences (alternate function keys)\n4. SGR mouse protocol (1006) for precise coordinates\n5. Bracketed paste mode (200~/201~)\n6. Focus events (CSI I / CSI O)\n7. Optional: Kitty keyboard protocol (feature-gated)\n\n## Event Coalescing (Recommended)\n- Mouse move: keep latest position per frame\n- Resize: keep latest size per tick\n- Key repeat: optionally surface KeyEventKind::Repeat if kitty protocol enabled\n\n## Exit Criteria\n- Parser passes fuzzing with random byte streams\n- Deterministic tests for all key/mouse/paste/resize sequences\n- Hard bounds on sequence lengths enforced\n- No panics on any input","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:05:35.653437996Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:21.059788622Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.5","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:05:35.653437996Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.5","depends_on_id":"bd-10i.4","type":"blocks","created_at":"2026-01-31T22:21:21.059758726Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.5.1","title":"Implement InputParser state machine","description":"# Implement InputParser state machine\n\n## Objective\nImplement robust terminal input parsing with DoS protection.\n\n## Parser States\nenum ParserState {\n    Ground,    // Normal character input\n    Escape,    // After ESC\n    Csi,       // After ESC [\n    CsiParam,  // Collecting CSI parameters\n    Osc,       // After ESC ]\n    Dcs,       // After ESC P\n    Ss3,       // After ESC O\n}\n\n## Transitions\nGround:\n  ESC (0x1B) -> Escape\n  0x00 -> Key(Null, Ctrl)\n  0x01-0x1A -> Key(Ctrl+A..Z)\n  0x7F -> Key(Backspace)\n  0x80+ -> UTF-8 sequence\n  other -> Key(Char)\n\nEscape:\n  [ -> Csi\n  O -> Ss3\n  ] -> Osc\n  P -> Dcs\n  other -> Key(Alt+char) + Ground\n\nCsi:\n  0-9;:<=>? -> CsiParam\n  A-Za-z~ -> parse + Ground\n\nCsiParam:\n  0-9;: -> stay\n  A-Za-z~Mm -> parse + Ground\n\nSs3:\n  A-S -> function key + Ground\n\nOsc:\n  BEL (0x07) -> complete + Ground\n  ESC \\\\ -> complete + Ground\n\n## DoS Protection Limits\nconst MAX_CSI_LEN: usize = 256;   // Prevent CSI bomb\nconst MAX_OSC_LEN: usize = 4096;\nconst MAX_DCS_LEN: usize = 4096;\nconst MAX_PASTE_LEN: usize = 1024 * 1024;  // 1MB\n\nIf limit exceeded: abandon sequence, return to Ground.\n\n## Special Sequences\n\n### Bracketed Paste\nCSI 200 ~ -> start paste mode\nCSI 201 ~ -> end paste mode, emit Paste event\n\n### Focus Events\nCSI I -> Focus(true)\nCSI O -> Focus(false)\n\n### SGR Mouse (1006)\nCSI < params M -> mouse down\nCSI < params m -> mouse up\nparams: button ; x ; y\n\n### Arrow Keys\nCSI A -> Up\nCSI B -> Down\nCSI C -> Right\nCSI D -> Left\n\n### Function Keys\nSs3 P -> F1\nSs3 Q -> F2\netc.\n\nCSI 15 ~ -> F5\nCSI 17 ~ -> F6\netc.\n\n## Implementation\npub struct InputParser {\n    state: ParserState,\n    buffer: Vec<u8>,\n    paste_buffer: Vec<u8>,\n    in_paste: bool,\n    // Limits\n    max_csi_len: usize,\n    max_osc_len: usize,\n    max_paste_len: usize,\n}\n\nimpl InputParser {\n    pub fn new() -> Self { ... }\n\n    pub fn parse(&mut self, input: &[u8]) -> Vec<Event> {\n        let mut events = Vec::new();\n        for &byte in input {\n            if let Some(event) = self.process_byte(byte) {\n                events.push(event);\n            }\n        }\n        events\n    }\n}\n\n## Tests Required\n- [ ] ASCII characters parsed correctly\n- [ ] Arrow keys produce correct events\n- [ ] Function keys F1-F12\n- [ ] Modifiers (Ctrl, Alt, Shift)\n- [ ] Mouse events decoded correctly\n- [ ] Bracketed paste collected\n- [ ] Focus events detected\n- [ ] DoS limits enforced\n- [ ] Invalid sequences don't panic\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Fuzz testing passes\n- [ ] No panics on any input\n- [ ] Linear time complexity","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:14:55.632491690Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:05.373599141Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.5.1","depends_on_id":"bd-10i.2.4","type":"blocks","created_at":"2026-01-31T22:22:05.373564095Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.5.1","depends_on_id":"bd-10i.5","type":"parent-child","created_at":"2026-01-31T22:14:55.632491690Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.6","title":"Phase 4: Styling (Split Responsibilities)","description":"# Phase 4: Styling (Split Responsibilities)\n\n## Purpose\nImplement a style system that separates concerns: renderer-facing CellStyle is tiny and fast, while higher-level style (theme/semantic colors) resolves into CellStyle before drawing.\n\n## Architecture Decision\nStyle is split by responsibility:\n- CellStyle: tiny, renderer-facing (packed fg/bg/attrs/link-id)\n- FullStyle: higher-level with all properties + explicit tracking via bitflags\n- Theme: semantic color slots + presets\n\n## Components\n\n### StyleFlags (8 bits)\nBOLD, DIM, ITALIC, UNDERLINE, BLINK, REVERSE, STRIKETHROUGH, HIDDEN\n\n### Props Bitflags (64 bits)\nTracks which properties are explicitly set for proper inheritance.\nUnset properties inherit from parent style.\n\n### Color System\n- AdaptiveColor: can resolve differently for light/dark themes\n- ColorProfile detection: Ascii, Ansi (16), Ansi256 (256), TrueColor (24-bit)\n- Color downgrade: TrueColor -> 256 -> 16 -> ASCII\n- NO_COLOR environment variable respected\n\n### Border System\n- Presets: Rounded, Square, Double, Heavy, Ascii, Hidden\n- Custom borders supported\n- All corner and edge characters defined\n\n### Markup Parser (Optional Layer)\n- Regex-based parser for Rich-style markup: [bold red]text[/]\n- Escape sequences: \\[ becomes literal [\n- Style stack for proper nesting\n- Feature-gated, not part of kernel\n\n## Exit Criteria\n- Deterministic style merge with explicit masks\n- Theme resolution documented and tested\n- Markup parsing correct under tests (feature-gated)\n- Color downgrade works for all profile levels","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:05:49.668320221Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:21.317358778Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.6","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:05:49.668320221Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.6","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T22:21:21.317323021Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.7","title":"Phase 5: Layout + Components (Widgets Ring)","description":"# Phase 5: Layout + Components (Widgets Ring)\n\n## Purpose\nImplement the widget layer that builds on kernel primitives. Widgets are ring-2 concepts - they depend on the kernel but the kernel does not depend on them.\n\n## Renderable Trait\nThe core abstraction for components:\n- measure(&self, ctx: &RenderContext) -> Measurement\n- render(&self, ctx: &RenderContext, rect: Rect, buffer: &mut Buffer)\n\n## Measurement Protocol\n- minimum: tightest compression width\n- maximum: ideal unconstrained width\n- union(): for side-by-side layout (max of both)\n- stack(): for vertical stacking (sum of both)\n\n## v1 Essential Widgets (Agent Harness Needs)\n\n### Viewport / Log Viewer\n- Scrollable text area for streaming logs\n- Essential for agent harness UIs\n\n### Panel\n- Bordered container with optional title\n- Border styles: Rounded, Square, Double, Heavy, Ascii, Hidden\n- Title alignment: Left, Center, Right\n\n### Spinner\n- Animated progress indicator\n- Styles: Dots, Line, Braille, Bounce, Custom\n- Frame advancement via tick()\n\n### Progress Bar\n- Value 0.0-1.0 with optional percentage display\n- Customizable filled/empty characters and colors\n\n### Text Input / Prompt\n- Single-line editable text field\n- Cursor management, selection (future)\n\n### Status Line\n- Fixed-position information display\n- For tool indicators, status messages\n\n## Hit Testing (Optional)\nHitGrid for mouse affordances - maps screen positions to interactive elements.\n\n## Exit Criteria\n- Snapshot tests for all widgets across themes and sizes\n- Hit testing works where applicable\n- Widgets compose correctly via Renderable trait","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-31T22:06:02.781831931Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:21.822429868Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.7","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:06:02.781831931Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.7","depends_on_id":"bd-10i.5","type":"blocks","created_at":"2026-01-31T22:21:21.822401345Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.7","depends_on_id":"bd-10i.6","type":"blocks","created_at":"2026-01-31T22:21:21.560738568Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8","title":"Phase 6: Runtime + Agent Harness Reference App","description":"# Phase 6: Runtime + Agent Harness Reference App\n\n## Purpose\nImplement the optional-but-recommended Bubbletea/Elm-style runtime and build a reference agent harness app that proves the architecture works for its primary use case.\n\n## Runtime Model (Bubbletea/Elm Lineage)\n\n### Model Trait\n- init() -> Cmd: initialization commands\n- update(msg) -> Cmd: state transitions\n- view(&self, frame: &mut Frame): render current state\n\n### Cmd Enum\n- None: no-op\n- Quit: exit application\n- Batch(Vec<Cmd>): parallel commands\n- Sequence(Vec<Cmd>): sequential commands\n- Msg(M): send message to self\n- Tick(Duration): schedule tick\n- Async integration (feature-gated): threadpool or tokio\n\n### Program Responsibilities\n- Own terminal lifecycle (raw mode, mouse, paste, focus, alt screen)\n- Poll input -> Event -> Message\n- Run update loop, schedule ticks/commands\n- Render frames only when dirty\n- Enforce screen mode policy (Inline/AltScreen)\n- FPS cap and frame coalescing\n\n## Deterministic Simulator (Stop regressions forever)\nProgramSimulator that:\n- Injects sequence of Events/Messages\n- Captures produced Frames\n- Enables snapshot tests for widgets and full apps\n- Runs without real terminal (no flakiness)\n\n## Agent Harness Reference App\nThe design forcing function - not 'just an example':\n- Inline scrollback log stream + UI region\n- Tool indicators, status line, input area\n- Streaming render updates\n- No flicker, no corruption\n- Survives resize\n- Exits cleanly on panic\n\n## What 'Agent-Ergonomic' Means in Practice\n- Hello world harness in <200 LOC\n- Tool output streaming is one function call\n- Pinned bottom UI is one config option\n- Temporary full-screen modal supported without rewriting app\n\n## Exit Criteria\n- Harness demo passes PTY tests\n- Inline mode stable under sustained output\n- Simulator enables deterministic testing","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-31T22:06:20.392811659Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:22.065151058Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:06:20.392811659Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8","depends_on_id":"bd-10i.7","type":"blocks","created_at":"2026-01-31T22:21:22.065119348Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.1","title":"Implement TerminalWriter with inline mode support","description":"# Implement TerminalWriter with inline mode support\n\n## Objective\nImplement the unified terminal output coordinator that enforces the one-writer rule and implements inline mode correctly.\n\n## Why TerminalWriter?\nThe TerminalWriter is the component that makes inline mode work. It:\n- Serializes log writes and UI presents\n- Implements the cursor save/restore contract\n- Manages scroll regions (when optimization enabled)\n- Ensures single buffered write per operation\n\n## Architecture\npub struct TerminalWriter<W: Write> {\n    session: TerminalSession<W>,\n    presenter: Presenter<W>,\n    screen_mode: ScreenMode,\n    ui_anchor: UiAnchor,\n    prev_buffer: Buffer,\n    pool: GraphemePool,\n    links: LinkRegistry,\n}\n\npub enum ScreenMode {\n    Inline { ui_height: u16 },\n    AltScreen,\n}\n\npub enum UiAnchor {\n    Bottom,  // Default for agent harness\n    Top,\n}\n\n## Inline Mode Present Sequence (Overlay Redraw)\n\npub fn present_ui(&mut self, buffer: &Buffer) -> io::Result<()> {\n    if let ScreenMode::Inline { ui_height } = self.screen_mode {\n        // 1. Begin sync output if available\n        if self.session.capabilities().sync_output {\n            write!(self.writer, '\\x1b[?2026h')?;\n        }\n\n        // 2. Save cursor (DEC or ANSI)\n        write!(self.writer, '\\x1b7')?;  // DEC save\n\n        // 3. Move to UI anchor\n        let (_, term_height) = self.terminal_size();\n        let ui_y = term_height - ui_height;\n        write!(self.writer, '\\x1b[{};1H', ui_y + 1)?;\n\n        // 4. Clear UI region only (not full screen!)\n        for _ in 0..ui_height {\n            write!(self.writer, '\\x1b[2K\\n')?;  // Clear line\n        }\n        write!(self.writer, '\\x1b[{};1H', ui_y + 1)?;  // Back to anchor\n\n        // 5. Present diffed UI\n        let diff = BufferDiff::compute(&self.prev_buffer, buffer);\n        self.presenter.present(buffer, &diff, &self.pool, &self.links)?;\n\n        // 6. Restore cursor\n        write!(self.writer, '\\x1b8')?;  // DEC restore\n\n        // 7. End sync output\n        if self.session.capabilities().sync_output {\n            write!(self.writer, '\\x1b[?2026l')?;\n        }\n\n        self.writer.flush()?;\n        std::mem::swap(&mut self.prev_buffer, buffer);\n    }\n    Ok(())\n}\n\n## Log Writing (Inline Mode)\npub fn write_log(&mut self, text: &str) -> io::Result<()> {\n    if let ScreenMode::Inline { .. } = self.screen_mode {\n        // Log writes go to scrollback region (above UI)\n        // Just write normally - terminal scrolls\n        // The next present_ui will redraw UI in correct position\n        self.writer.write_all(text.as_bytes())?;\n        self.writer.flush()\n    } else {\n        // AltScreen: no scrollback, might need different handling\n        Ok(())\n    }\n}\n\n## Scroll Region Optimization (Optional)\nWhen capabilities.scroll_region and policy allows:\n- Set DECSTBM to constrain scrolling\n- Log writes stay in scroll region\n- UI stays pinned outside scroll region\n- Must restore on exit\n\n## Tests Required\n- [ ] present_ui doesn't corrupt scrollback\n- [ ] Cursor restored to correct position\n- [ ] Multiple present/log cycles stable\n- [ ] Resize handled correctly\n- [ ] PTY tests verify behavior\n\n## Acceptance Criteria\n- [ ] Inline mode works without flicker\n- [ ] PTY tests pass\n- [ ] Cursor contract enforced\n- [ ] No scrollback corruption","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:16:09.208130189Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:26.927218289Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.1","depends_on_id":"bd-10i.10.1","type":"blocks","created_at":"2026-01-31T22:22:26.927181830Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.1","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T22:22:26.665689264Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.1","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T22:16:09.208130189Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.2","title":"Implement Program/Model/Cmd runtime","description":"# Implement Program/Model/Cmd runtime\n\n## Objective\nImplement the Bubbletea/Elm-style runtime that manages the update/view loop.\n\n## Why This Runtime?\n- Separates state (Model) from rendering (View)\n- Makes apps testable via deterministic simulator\n- Handles event loop complexity\n- Provides command pattern for side effects\n\n## Core Trait\npub trait Model: Sized {\n    type Message: From<Event> + Send + 'static;\n\n    /// Initialize model, return startup commands\n    fn init(&mut self) -> Cmd<Self::Message> {\n        Cmd::none()\n    }\n\n    /// Handle message, return commands\n    fn update(&mut self, msg: Self::Message) -> Cmd<Self::Message>;\n\n    /// Render current state to frame\n    fn view(&self, frame: &mut Frame);\n}\n\n## Command Type\npub enum Cmd<M> {\n    None,\n    Quit,\n    Batch(Vec<Cmd<M>>),      // Parallel execution\n    Sequence(Vec<Cmd<M>>),   // Sequential execution\n    Msg(M),                  // Send message to self\n    Tick(Duration),          // Schedule tick\n    // Feature-gated async\n    #[cfg(feature = 'async')]\n    Async(BoxFuture<'static, M>),\n}\n\nimpl<M> Cmd<M> {\n    pub fn none() -> Self { Self::None }\n    pub fn quit() -> Self { Self::Quit }\n    pub fn msg(m: M) -> Self { Self::Msg(m) }\n    pub fn batch(cmds: Vec<Self>) -> Self { Self::Batch(cmds) }\n    pub fn tick(d: Duration) -> Self { Self::Tick(d) }\n}\n\n## Program (Runtime)\npub struct Program<M: Model> {\n    model: M,\n    writer: TerminalWriter<Stdout>,\n    input_parser: InputParser,\n    running: bool,\n    tick_rate: Option<Duration>,\n    last_tick: Instant,\n    dirty: bool,\n}\n\nimpl<M: Model> Program<M> {\n    pub fn new(model: M, screen_mode: ScreenMode) -> io::Result<Self> {\n        // Set up terminal\n        // Initialize writer\n        // Start input thread/poll\n    }\n\n    pub fn run(&mut self) -> io::Result<()> {\n        // Initialize\n        let cmd = self.model.init();\n        self.execute_cmd(cmd)?;\n\n        // Main loop\n        while self.running {\n            // Poll for input (with tick timeout)\n            if let Some(event) = self.poll_event()? {\n                let msg = M::Message::from(event);\n                let cmd = self.model.update(msg);\n                self.execute_cmd(cmd)?;\n                self.dirty = true;\n            }\n\n            // Tick handling\n            if self.should_tick() {\n                // Send tick message or just re-render\n                self.dirty = true;\n            }\n\n            // Render if dirty\n            if self.dirty {\n                let mut frame = self.new_frame();\n                self.model.view(&mut frame);\n                self.writer.present_ui(&frame.buffer)?;\n                self.dirty = false;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute_cmd(&mut self, cmd: Cmd<M::Message>) -> io::Result<()> {\n        match cmd {\n            Cmd::None => {}\n            Cmd::Quit => self.running = false,\n            Cmd::Msg(m) => {\n                let cmd = self.model.update(m);\n                self.execute_cmd(cmd)?;\n            }\n            Cmd::Batch(cmds) => {\n                for c in cmds {\n                    self.execute_cmd(c)?;\n                }\n            }\n            Cmd::Tick(d) => {\n                self.tick_rate = Some(d);\n            }\n            // ...\n        }\n        Ok(())\n    }\n}\n\n## App Builder (Ergonomic Entry Point)\npub struct App;\n\nimpl App {\n    pub fn new<M: Model>(model: M) -> AppBuilder<M> {\n        AppBuilder { model, screen_mode: ScreenMode::Inline { ui_height: 4 } }\n    }\n}\n\npub struct AppBuilder<M: Model> {\n    model: M,\n    screen_mode: ScreenMode,\n}\n\nimpl<M: Model> AppBuilder<M> {\n    pub fn screen_mode(mut self, mode: ScreenMode) -> Self {\n        self.screen_mode = mode;\n        self\n    }\n\n    pub fn run(self) -> Result<()> {\n        let mut program = Program::new(self.model, self.screen_mode)?;\n        program.run()?;\n        Ok(())\n    }\n}\n\n## Tests Required\n- [ ] Model::update called on events\n- [ ] Model::view called on dirty\n- [ ] Cmd::Quit stops loop\n- [ ] Cmd::Batch executes all\n- [ ] Tick scheduling works\n\n## Acceptance Criteria\n- [ ] Hello world app works\n- [ ] Deterministic when using simulator\n- [ ] Clean shutdown","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:16:30.741993686Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:27.425385882Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.2","depends_on_id":"bd-10i.2.6","type":"blocks","created_at":"2026-01-31T22:22:27.425356768Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.2","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T22:16:30.741993686Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.2","depends_on_id":"bd-376","type":"blocks","created_at":"2026-01-31T22:22:27.180730950Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.3","title":"Implement ProgramSimulator for deterministic testing","description":"# Implement ProgramSimulator for deterministic testing\n\n## Objective\nCreate a simulator that runs Model logic deterministically without a real terminal.\n\n## Why Simulator?\n- Tests must be deterministic (no real terminal)\n- Snapshot tests for widgets and apps\n- Can inject arbitrary event sequences\n- No flakiness from timing/IO\n\n## Structure\npub struct ProgramSimulator<M: Model> {\n    model: M,\n    frames: Vec<Buffer>,\n    messages: Vec<M::Message>,\n    time: Instant,  // Simulated time\n}\n\nimpl<M: Model> ProgramSimulator<M> {\n    pub fn new(model: M) -> Self {\n        Self {\n            model,\n            frames: Vec::new(),\n            messages: Vec::new(),\n            time: Instant::now(),\n        }\n    }\n\n    /// Inject events and process\n    pub fn inject_events(&mut self, events: &[Event]) {\n        for event in events {\n            let msg = M::Message::from(event.clone());\n            self.messages.push(msg.clone());\n            let _cmd = self.model.update(msg);\n            // Note: Commands are captured but not executed\n            // (async/IO commands meaningless in simulation)\n        }\n    }\n\n    /// Send specific message\n    pub fn send(&mut self, msg: M::Message) {\n        self.messages.push(msg.clone());\n        let _cmd = self.model.update(msg);\n    }\n\n    /// Capture current frame\n    pub fn capture_frame(&mut self, width: u16, height: u16) -> &Buffer {\n        let mut frame = Frame {\n            buffer: Buffer::new(width, height),\n            hit_grid: None,\n            cursor_position: None,\n            cursor_visible: true,\n        };\n        self.model.view(&mut frame);\n        self.frames.push(frame.buffer);\n        self.frames.last().unwrap()\n    }\n\n    /// Get all captured frames\n    pub fn frames(&self) -> &[Buffer] {\n        &self.frames\n    }\n\n    /// Get message history\n    pub fn messages(&self) -> &[M::Message] {\n        &self.messages\n    }\n\n    /// Advance simulated time\n    pub fn advance_time(&mut self, duration: Duration) {\n        self.time += duration;\n    }\n\n    /// Get current model reference\n    pub fn model(&self) -> &M {\n        &self.model\n    }\n}\n\n## Snapshot Testing Pattern\n#[test]\nfn counter_snapshot() {\n    let mut sim = ProgramSimulator::new(Counter { value: 0 });\n\n    // Inject key press\n    sim.inject_events(&[Event::Key(KeyEvent {\n        code: KeyCode::Char('+'),\n        modifiers: Modifiers::empty(),\n    })]);\n\n    // Capture frame\n    let frame = sim.capture_frame(80, 24);\n\n    // Compare with golden snapshot\n    insta::assert_snapshot!(frame_to_string(frame));\n}\n\n## Widget Testing Pattern\n#[test]\nfn spinner_frames() {\n    let mut spinner = Spinner::new('Loading');\n    let ctx = RenderContext::test();\n    let mut frames = Vec::new();\n\n    for _ in 0..10 {\n        spinner.tick();\n        let mut buf = Buffer::new(20, 1);\n        spinner.render(&ctx, Rect::new(0, 0, 20, 1), &mut buf);\n        frames.push(buf);\n    }\n\n    // Verify animation frames differ\n    assert_ne!(frames[0], frames[1]);\n}\n\n## Tests Required\n- [ ] inject_events processes all\n- [ ] capture_frame renders correctly\n- [ ] Messages recorded in order\n- [ ] Works without terminal\n\n## Acceptance Criteria\n- [ ] Snapshot tests work\n- [ ] No IO dependencies\n- [ ] Deterministic results","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:16:48.395010451Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:27.666172346Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.3","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T22:16:48.395010451Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.3","depends_on_id":"bd-10i.8.2","type":"blocks","created_at":"2026-01-31T22:22:27.666141989Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.9","title":"Phase 7: Extras + Polish","description":"# Phase 7: Extras + Polish\n\n## Purpose\nAdd feature-gated extras, complete documentation, run performance audits, and validate terminal compatibility. This is the final polish before v1.\n\n## Documentation Deliverables\n- Rustdoc for all public APIs\n- Agent harness tutorial (inline + modal alt-screen patterns)\n- Inline vs alt-screen explanation (scrollback tradeoffs)\n- One-writer rule guidance + supported routing patterns\n- Windows v1 limitations + compatibility notes\n\n## Examples Gallery\nReference implementations demonstrating:\n- Minimal hello world\n- Streaming log viewer\n- Interactive dashboard\n- Full agent harness\n\n## Performance Audit\n- Verify all budgets met\n- Profile hot paths\n- Benchmark regression tests in CI\n- Track bytes emitted per frame\n\n## Terminal Compatibility Testing\n| Feature | Kitty | WezTerm | Alacritty | Ghostty | iTerm2 | GNOME Term | Win Term |\n|---------|-------|---------|-----------|---------|--------|------------|----------|\n| True Color |  |  |  |  |  |  |  |\n| Sync Output |  |  |  |  |  |  |  |\n| OSC 8 Links |  |  |  |  |  |  |  |\n| Kitty Kbd |  |  |  |  |  |  |  |\n\n## Feature-Gated Extras\n- Markdown renderer\n- Syntax highlighting (tree-sitter or similar)\n- Forms / pickers\n- Export adapters (HTML/SVG/text)\n- Optional clipboard integration (OSC 52 output)\n\n## CI/CD Setup\n- clippy + fmt enforcement\n- unit/property/snapshot/PTY tests\n- Performance benchmarks as baselines\n- Feature matrix build: default, +simd, +extras\n\n## Exit Criteria\n- Stable kernel API\n- Docs + examples complete\n- Performance baselines recorded\n- Compatibility matrix validated\n- All quality gates pass","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-31T22:06:35.450846082Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:29.267843341Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.9","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:06:35.450846082Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.9","depends_on_id":"bd-10i.8","type":"blocks","created_at":"2026-01-31T22:21:29.267814226Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10x","title":"Implement Style struct with cascading/merging","description":"PHASE 4 - STYLING CORE\n\n## Background\nStyle struct is the unified styling type that combines colors, attributes, and modifiers into a single composable unit. Must support cascading/merging like CSS inheritance.\n\n## Technical Requirements\n- Style struct containing:\n  - foreground: Option<PackedRgba>\n  - background: Option<PackedRgba>\n  - attrs: Option<CellAttrs>\n  - underline_color: Option<PackedRgba>\n- Cascading merge: child.merge(parent) fills in None fields from parent\n- Override merge: parent.patch(child) replaces with child's Some values\n- Builder pattern for ergonomic construction\n- impl Default with all None (transparent/inheriting)\n\n## Design Rationale\nOption-wrapped fields enable CSS-like inheritance where unset properties inherit from parent context. This matches user mental model from web development.\n\n## Acceptance Criteria\n- [ ] Style struct with Option-wrapped components\n- [ ] merge() for cascading (child wins on conflict)\n- [ ] patch() for override (explicit values win)\n- [ ] Builder pattern: Style::new().fg(color).bold()\n- [ ] #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n- [ ] Zero-cost when all fields are None\n- [ ] Property tests for merge associativity\n\n## Performance Budget\n- Style merge: < 5ns (branchless bitfield ops)\n- sizeof(Style)  24 bytes\n\n## Location: ftui-style crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:18:29.746530502Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:11.580195940Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10x","depends_on_id":"bd-10i.3.2","type":"blocks","created_at":"2026-01-31T22:22:11.317919006Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10x","depends_on_id":"bd-10i.3.3","type":"blocks","created_at":"2026-01-31T22:22:11.580166805Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-16k","title":"Unicode width corpus testing with WTF-8","description":"TESTING - UNICODE WIDTH CORPUS\n\n## Background\nUnicode width calculation is notoriously complex with edge cases around emoji, CJK, combining characters, and ZWJ sequences. A comprehensive test corpus is essential for correctness.\n\n## Technical Requirements\n- Test corpus categories:\n  - Basic ASCII (width 1)\n  - CJK Unified Ideographs (width 2)\n  - Fullwidth ASCII variants (width 2)\n  - Halfwidth Katakana (width 1)\n  - Emoji with modifiers (width varies)\n  - ZWJ sequences (flag emoji, family emoji)\n  - Combining characters (width 0)\n  - Control characters (width 0)\n  - Ambiguous width characters (context-dependent)\n- WTF-8 handling for unpaired surrogates\n- Terminal-specific width (vs Unicode Standard)\n- Test against unicode-width crate results\n\n## Known Edge Cases\n-  (family emoji ZWJ) - varies by terminal\n-  (flag ZWJ) - often renders as 2 cells\n- Regional indicators (flag pairs)\n- Variation selectors (VS15/VS16)\n\n## Design Rationale\nCorrectness in width calculation directly impacts rendering quality. The corpus captures real-world edge cases that simple tests miss.\n\n## Acceptance Criteria\n- [ ] Corpus with 1000+ test cases\n- [ ] Categorized by width type\n- [ ] Known terminal-specific behaviors documented\n- [ ] Property tests for grapheme iteration\n- [ ] Fuzz testing for malformed input\n- [ ] Benchmark for width calculation performance\n\n## Location: ftui-text crate tests/","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:20:38.382705649Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:45.728203171Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-16k","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:22:45.728172253Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1qb","title":"Implement Image widget with protocol detection","description":"PHASE 7 - EXTRAS: IMAGE WIDGET\n\n## Background\nImage widget displays images in terminal using Kitty Graphics Protocol, iTerm2 inline images, or Sixel fallback. Requires protocol detection and graceful degradation.\n\n## Technical Requirements\n- Protocol detection:\n  - Kitty Graphics Protocol (XTGETTCAP query)\n  - iTerm2 inline images (TERM_PROGRAM check)\n  - Sixel (DA2 response parsing)\n  - Fallback: ASCII/Braille representation\n- Image loading via image crate\n- Resize/fit modes: Contain, Cover, Stretch, None\n- Aspect ratio preservation\n- Partial update for animated GIFs\n- Memory management for large images\n\n## Design Rationale\nImage support is a premium feature gated behind 'image' flag. Protocol detection happens once at startup and caches result. Fallback ensures graceful degradation.\n\n## Acceptance Criteria\n- [ ] Protocol detection and caching\n- [ ] Kitty Graphics Protocol implementation\n- [ ] iTerm2 inline image implementation\n- [ ] Sixel fallback (optional sub-feature)\n- [ ] ASCII fallback when no protocol available\n- [ ] Resize mode configuration\n- [ ] Aspect ratio handling\n- [ ] Feature gate: image\n\n## Performance Budget\n- Protocol detection: < 50ms (one-time)\n- Image encode/transmit: proportional to size\n\n## Location: ftui-extras crate (feature = \"image\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:20:04.942919291Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:35.619831992Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1qb","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T22:22:35.619803037Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1xo","title":"Windows Terminal compatibility layer","description":"PHASE 7 - POLISH: WINDOWS SUPPORT\n\n## Background\nWindows Terminal v1 support is deferred but must have clear integration path. Modern Windows Terminal supports ANSI, older conhost needs different handling.\n\n## Technical Requirements (v1 Scope - Windows Terminal Only)\n- Detect Windows Terminal vs legacy conhost\n- Enable VT processing mode via SetConsoleMode\n- Handle Windows-specific escape sequences\n- PTY spawning via ConPTY API\n- Signal handling differences (Ctrl+C, Ctrl+Break)\n- Path handling for Windows conventions\n\n## Out of Scope for v1\n- Legacy conhost support (Windows 7/8)\n- PowerShell-specific handling\n- Windows-specific widgets\n\n## Design Rationale\nPer ADR-004, Windows v1 targets modern Windows Terminal only. This dramatically simplifies implementation while covering majority of Windows developer use.\n\n## Acceptance Criteria\n- [ ] Windows Terminal detection\n- [ ] VT mode enabling\n- [ ] ConPTY integration for PTY tests\n- [ ] Signal handling shim\n- [ ] CI testing on Windows\n- [ ] Feature gate: windows\n\n## Testing\n- GitHub Actions Windows runner\n- Manual testing on Windows Terminal\n- Document known limitations\n\n## Location: ftui-render crate + ftui-pty crate (platform-specific code)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:20:16.533908639Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:36.112222Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xo","depends_on_id":"bd-10i.10.4","type":"blocks","created_at":"2026-01-31T22:22:36.112191833Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xo","depends_on_id":"bd-10i.8.1","type":"blocks","created_at":"2026-01-31T22:22:35.870315746Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2a5","title":"API documentation and examples suite","description":"PHASE 7 - POLISH: DOCUMENTATION\n\n## Background\nComprehensive documentation is essential for library adoption. Must include API docs, guides, and runnable examples covering all major use cases.\n\n## Technical Requirements\n\n### API Documentation\n- All public types documented with /// comments\n- Module-level documentation with usage examples\n- Cross-linking between related types\n- Platform-specific behavior documented\n- Feature flag documentation\n- Safety documentation for any unsafe code\n\n### Examples Suite\n- examples/hello.rs - Minimal 'Hello World'\n- examples/counter.rs - Basic state management\n- examples/input.rs - Text input handling\n- examples/layout.rs - Flex/Grid layouts\n- examples/styling.rs - Themes and styles\n- examples/table.rs - Data tables\n- examples/async.rs - Async runtime integration\n- examples/inline.rs - Inline mode demo\n\n### Guide Documentation\n- Getting Started guide\n- Architecture overview\n- Migration guide from Ratatui\n- Performance tuning guide\n- Testing guide\n\n## Design Rationale\nDocumentation is a feature. Examples serve as both learning resources and regression tests. Keeping docs close to code via rustdoc ensures accuracy.\n\n## Acceptance Criteria\n- [ ] 100% public API documented\n- [ ] All examples compile and run\n- [ ] Examples cover each major widget\n- [ ] Guide for each major topic\n- [ ] docs.rs badge in README\n- [ ] Changelog maintained\n\n## Location: Workspace-wide + docs/ directory","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:20:27.193051613Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:36.625959939Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2a5","depends_on_id":"bd-10i.8.3","type":"blocks","created_at":"2026-01-31T22:22:36.366148400Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2a5","depends_on_id":"bd-3k4","type":"blocks","created_at":"2026-01-31T22:22:36.625930213Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2m5","title":"SIMD-accelerated cell comparison and buffer operations","description":"PERFORMANCE - SIMD OPTIMIZATION\n\n## Background\nCell comparison dominates diff performance. The 16-byte Cell design enables 4 cells per 64-byte cache line, optimized for SIMD comparison. This task implements SIMD acceleration.\n\n## Technical Requirements\n- SIMD cell equality comparison:\n  - Compare 4 cells (64 bytes) at once with AVX2\n  - Fallback to 2 cells (32 bytes) with SSE2\n  - Scalar fallback for non-x86\n- Buffer row comparison:\n  - Find first differing cell in row\n  - Find changed row spans for minimal diff\n- Memory alignment:\n  - Buffer rows aligned to 64 bytes\n  - Cell array uses aligned allocation\n\n## Implementation Strategy\n1. Use std::simd (portable_simd) when stabilized\n2. Until then: safe abstraction over platform intrinsics\n3. Feature gate: 'simd' (enabled by default on x86_64)\n4. Graceful fallback with #[cfg] guards\n\n## Design Rationale\nThe plan explicitly calls out SIMD as the optimization path for cell comparison. 16-byte Cell alignment is specifically chosen to enable 4-way comparison.\n\n## Acceptance Criteria\n- [ ] SIMD cell comparison implementation\n- [ ] AVX2 path for x86_64\n- [ ] SSE2 fallback\n- [ ] Scalar fallback for other platforms\n- [ ] Benchmark showing speedup\n- [ ] No unsafe without exhaustive safety comments\n- [ ] Runtime feature detection where appropriate\n\n## Performance Budget\n- Cell comparison: < 1ns (target from plan)\n- Row comparison: < 10ns per cell\n- Buffer diff: sublinear with SIMD\n\n## Location: ftui-simd crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:20:50.805814276Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:46.216494196Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2m5","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T22:22:46.216463669Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2u4","title":"Implement snapshot/golden testing framework","description":"TESTING - SNAPSHOT TESTS\n\n## Background\nSnapshot testing captures expected Buffer output and compares against future runs. Essential for preventing visual regressions and validating rendering correctness.\n\n## Technical Requirements\n- Snapshot capture:\n  - Buffer  text representation (with ANSI or stripped)\n  - Buffer  binary serialization\n  - Configurable normalization (strip cursor position, etc.)\n- Snapshot storage:\n  - tests/snapshots/ directory\n  - Filename based on test name + variant\n  - Human-readable format for review\n- Comparison:\n  - Exact match mode\n  - Fuzzy match mode (ignore whitespace variations)\n  - Diff output on failure showing changes\n- Update workflow:\n  - BLESS=1 env var to update snapshots\n  - cargo insta integration optional\n\n## Design Rationale\nVisual output is hard to assert with unit tests. Snapshots capture 'known good' output and flag any changes for human review. Prevents subtle rendering regressions.\n\n## Acceptance Criteria\n- [ ] Snapshot capture API\n- [ ] Text and binary formats\n- [ ] Diff output on mismatch\n- [ ] Update/bless workflow\n- [ ] Integration with cargo test\n- [ ] Document snapshot review process\n- [ ] Sample snapshots for core widgets\n\n## Integration\n- Consider insta crate for snapshot management\n- Support parallel test execution\n- Snapshot files committed to git\n\n## Location: ftui-harness crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:21:02.513675763Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:45.971542074Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2u4","depends_on_id":"bd-10i.11.1","type":"blocks","created_at":"2026-01-31T22:22:45.971507198Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2uk","title":"Implement Text type with styled spans","description":"PHASE 4 - TEXT TYPE\n\n## Background\nText is the styled string type - a sequence of styled spans that can be rendered to a Buffer. Separates content from presentation while maintaining rich formatting.\n\n## Technical Requirements\n- Text struct: Vec<Span> where Span = (String, Style)\n- Efficient appending: text.push('hello', style)\n- Style inheritance: text.styled(base_style) applies to all spans\n- Width calculation: text.width() using unicode-width\n- Truncation: text.truncate(max_width, ellipsis)\n- Line iteration: text.lines() splits on newlines preserving styles\n- From implementations for &str, String, Cow<str>\n\n## Design Rationale\nText as first-class type enables styled string manipulation without Buffer allocation. Spans allow fine-grained styling within a single logical text unit.\n\n## Acceptance Criteria\n- [ ] Text struct with Span vector\n- [ ] Push/append API for building text\n- [ ] Style inheritance/override\n- [ ] Accurate unicode width calculation\n- [ ] Truncation with configurable ellipsis\n- [ ] Line splitting preserving span styles\n- [ ] impl Display for plain text output\n- [ ] Clone, PartialEq implementations\n\n## Performance Budget\n- Width calculation: O(n) with grapheme iteration\n- Style merge per span: < 5ns\n\n## Location: ftui-text crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:18:51.038800704Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:12.313241895Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2uk","depends_on_id":"bd-10i.3.5","type":"blocks","created_at":"2026-01-31T22:22:12.313212009Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2uk","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T22:22:12.067575457Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2wi","title":"Implement Grid layout for 2D positioning","description":"PHASE 5 - GRID LAYOUT\n\n## Background\nGrid layout provides 2D positioning with rows/columns. More powerful than Flex for dashboard-style layouts with multiple regions.\n\n## Technical Requirements\n- Grid struct with rows  cols dimensions\n- Cell addressing: grid[(row, col)]\n- Column/row constraints (reuse Flex constraint types)\n- Cell spanning: colspan/rowspan for merged cells\n- Gap between cells (row_gap, col_gap)\n- Area naming: grid.area('sidebar') returns Rect\n- Template syntax for declarative grid definition\n\n## Design Rationale\nCSS Grid concepts adapted for TUI. Area naming enables semantic layout references. Cell spanning handles common dashboard patterns.\n\n## Acceptance Criteria\n- [ ] Grid struct with constraint-based sizing\n- [ ] Row and column constraint solving\n- [ ] Cell span support (colspan, rowspan)\n- [ ] Named area definition and lookup\n- [ ] Gap configuration\n- [ ] Template DSL for grid definition\n- [ ] Overflow handling for too-small grids\n- [ ] Property tests for area calculations\n\n## Performance Budget\n- Grid solve for 1010: < 500s\n- Area lookup: O(1) after solve\n\n## Location: ftui-layout crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:19:13.186902512Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:19.086437578Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2wi","depends_on_id":"bd-yzu","type":"blocks","created_at":"2026-01-31T22:22:19.086408393Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2yd","title":"Implement StyleSheet registry for named styles","description":"PHASE 4 - STYLESHEET REGISTRY\n\n## Background\nStyleSheet provides named style registration similar to CSS classes. Enables theme-able applications and consistent style reuse without hardcoding colors.\n\n## Technical Requirements\n- StyleSheet struct with HashMap<StyleId, Style>\n- StyleId: either interned string or u32 index\n- Register named styles: stylesheet.define('error', Style::new().fg(RED).bold())\n- Lookup by name: stylesheet.get('error')\n- Style composition: stylesheet.compose(['base', 'error']) merges in order\n- Default styles for common semantic names (error, warning, info, success, muted)\n\n## Design Rationale\nNamed styles decouple visual appearance from widget logic. Themes can override the stylesheet without changing widget code. Matches patterns from Textual/Rich.\n\n## Acceptance Criteria\n- [ ] StyleSheet with define/get/compose API\n- [ ] StyleId type (string or integer based on perf analysis)\n- [ ] Thread-safe for read access (RwLock or immutable after init)\n- [ ] Default semantic style set\n- [ ] Style merging for composition\n- [ ] Clear error handling for missing styles\n\n## Integration Points\n- Widgets reference styles by name\n- Theme loading populates stylesheet\n- Buffer.set_style() accepts Style or StyleId\n\n## Location: ftui-style crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:18:40.688288609Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:11.824857915Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2yd","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T22:22:11.824828780Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-30h","title":"Implement Sparkline and Chart widgets","description":"PHASE 7 - EXTRAS: DATA VISUALIZATION\n\n## Background\nSparkline and Chart widgets provide data visualization for metrics, trends, and timeseries. Common requirement for monitoring dashboards and CLI tools.\n\n## Technical Requirements\n\n### Sparkline Widget\n- Compact single-line visualization\n- Data as Vec<f64> or iterator\n- Auto-scaling to min/max range\n- Configurable bar character set ()\n- Color gradient based on value\n- Reference line support (mean, threshold)\n\n### Chart Widget (BarChart, LineChart)\n- BarChart:\n  - Horizontal/vertical orientation\n  - Grouped and stacked modes\n  - Labels and value display\n  - Color per series\n- LineChart:\n  - Multiple series support\n  - Point markers optional\n  - Area fill under line\n  - Axis labels and ticks\n  - Legend positioning\n\n## Design Rationale\nFeature-gated for projects that need visualization. Sparkline is minimal overhead. Full charts use Canvas internally for rendering.\n\n## Acceptance Criteria\n- [ ] Sparkline with auto-scaling\n- [ ] Sparkline color gradient\n- [ ] BarChart with orientations\n- [ ] BarChart grouped/stacked\n- [ ] LineChart multi-series\n- [ ] LineChart axis rendering\n- [ ] Feature gate: charts\n\n## Location: ftui-extras crate (feature = \"charts\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:19:54.798796411Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:35.360701005Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-30h","depends_on_id":"bd-3k4","type":"blocks","created_at":"2026-01-31T22:22:35.360672091Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-376","title":"Implement interactive widgets (List, Scrollbar, Input)","description":"PHASE 5 - INTERACTIVE WIDGETS\n\n## Background\nInteractive widgets handle user input and state changes. List provides selectable items, Scrollbar visualizes scroll position, Input accepts text entry.\n\n## Technical Requirements\n\n### List Widget\n- Items with optional styling per item\n- Single/multi selection modes\n- Keyboard navigation (up/down/pageup/pagedown/home/end)\n- Highlight style for selected item\n- Scroll into view on selection change\n- Item filtering/search support\n\n### Scrollbar Widget\n- Vertical and horizontal orientation\n- Track, thumb, and arrow styles\n- Thumb size proportional to content ratio\n- Click/drag support (if mouse enabled)\n- Auto-hide when content fits\n\n### Input Widget\n- Single-line text input\n- Cursor positioning with blinking\n- Text selection (shift+arrow)\n- Clipboard operations (copy/paste)\n- Placeholder text when empty\n- Password mode (masked input)\n- Input validation hooks\n\n## Design Rationale\nThese widgets encapsulate common interaction patterns. State management follows Elm architecture - widgets emit events, parent handles state updates.\n\n## Acceptance Criteria\n- [ ] List with selection modes\n- [ ] List keyboard navigation\n- [ ] Scrollbar sizing algorithm\n- [ ] Scrollbar orientation support\n- [ ] Input cursor management\n- [ ] Input text selection\n- [ ] All widgets implement StatefulWidget trait\n- [ ] Event emission for state changes\n\n## StatefulWidget Trait\npub trait StatefulWidget {\n    type State;\n    fn render(&self, area: Rect, buf: &mut Buffer, state: &mut Self::State);\n}\n\n## Location: ftui-widgets crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:19:33.823793890Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:20.398953138Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-376","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T22:22:20.398922120Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-376","depends_on_id":"bd-wr2","type":"blocks","created_at":"2026-01-31T22:22:20.135191747Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3k4","title":"Implement Canvas widget for custom drawing","description":"PHASE 7 - EXTRAS: CANVAS WIDGET\n\n## Background\nCanvas widget enables arbitrary pixel/shape drawing using Braille/block characters. Useful for graphs, plots, and custom visualizations that exceed normal cell-based rendering.\n\n## Technical Requirements\n- Canvas coordinate system (virtual pixels mapped to cells)\n- Drawing primitives:\n  - Point, Line, Rectangle, Circle, Ellipse\n  - Polygon (filled/outline)\n  - Text at arbitrary positions\n- Braille mode: 24 dots per cell = 8 pixels\n- Block mode: 22 quadrants per cell = 4 pixels\n- Half-block mode: 21 vertical halves\n- Color support within resolution limits\n- Painter API for building drawings\n\n## Design Rationale\nFeature-gated extra for visualization use cases. Braille provides highest resolution but requires font support. Multiple modes allow fallback based on terminal capabilities.\n\n## Acceptance Criteria\n- [ ] Canvas struct with configurable resolution mode\n- [ ] All drawing primitives\n- [ ] Braille character mapping\n- [ ] Block character mapping\n- [ ] Color support per primitive\n- [ ] Painter builder pattern\n- [ ] Coordinate transformation (pan, zoom)\n- [ ] Feature gate: canvas\n\n## Performance Budget\n- Line rasterization: Bresenham's algorithm\n- 1000 points render: < 1ms\n\n## Location: ftui-extras crate (feature = \"canvas\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:19:44.847948610Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:35.106522209Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3k4","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:22:35.106494166Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-wr2","title":"Implement core widgets (Block, Paragraph, Table)","description":"PHASE 5 - CORE WIDGETS\n\n## Background\nCore widgets provide essential UI building blocks. Block is a container with borders/title, Paragraph renders styled text with wrapping, Table displays tabular data.\n\n## Technical Requirements\n\n### Block Widget\n- Border styles: None, Single, Double, Rounded, Thick, Custom\n- Title positioning: Top/Bottom  Left/Center/Right\n- Padding (inner margin)\n- Style for border and background\n- Child content area calculation\n\n### Paragraph Widget\n- Text rendering with word/char wrap modes\n- Alignment: Left, Center, Right, Justify\n- Scroll offset for long content\n- Line height/spacing\n- Style inheritance from parent\n\n### Table Widget\n- Header row with column titles\n- Column constraints (width, alignment)\n- Row selection/highlighting\n- Cell styling\n- Horizontal/vertical scroll\n- Fixed header during scroll\n\n## Design Rationale\nThese three widgets cover the majority of TUI use cases. Block is the universal container, Paragraph handles all text display, Table presents structured data.\n\n## Acceptance Criteria\n- [ ] Block with all border styles\n- [ ] Block title positioning\n- [ ] Paragraph word wrap\n- [ ] Paragraph alignment modes\n- [ ] Table column constraints\n- [ ] Table row selection\n- [ ] All widgets implement Widget trait\n- [ ] Style customization for all components\n- [ ] Comprehensive unit tests\n\n## Widget Trait\nAll widgets implement:\npub trait Widget {\n    fn render(&self, area: Rect, buf: &mut Buffer);\n}\n\n## Location: ftui-widgets crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:19:23.813896695Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:19.875729497Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-wr2","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:22:19.331465022Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-wr2","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:22:19.599179431Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-wr2","depends_on_id":"bd-yzu","type":"blocks","created_at":"2026-01-31T22:22:19.875690904Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-yzu","title":"Implement Flex layout with constraint solving","description":"PHASE 5 - FLEX LAYOUT\n\n## Background\nFlex layout provides 1D constraint-based sizing for rows/columns. Core layout primitive that most complex layouts build upon. Based on CSS Flexbox concepts adapted for terminal grid.\n\n## Technical Requirements\n- Flex struct with direction (Row/Column)\n- Constraint types:\n  - Fixed(u16): exact size\n  - Percent(f32): percentage of parent\n  - Min(u16): minimum size, grow to fill\n  - Max(u16): maximum size, shrink to fit\n  - Ratio(u16, u16): proportional sharing\n- Constraint solving algorithm:\n  1. Allocate Fixed constraints first\n  2. Calculate Percent based on remaining space\n  3. Distribute remainder to Min/Ratio proportionally\n  4. Clamp Max constraints\n- Gap/spacing between items\n- Cross-axis alignment: Start, Center, End, Stretch\n\n## Design Rationale\nFlex is simpler than full 2D grid but handles 90% of TUI layouts. Constraint types mirror Ratatui's proven model. Solving algorithm is deterministic for predictable layouts.\n\n## Acceptance Criteria\n- [ ] Flex struct with direction and items\n- [ ] Full constraint type enum\n- [ ] Deterministic constraint solver\n- [ ] Gap/margin support\n- [ ] Cross-axis alignment\n- [ ] Nested Flex support\n- [ ] Property tests for constraint invariants\n- [ ] Edge case handling (overflow, zero space)\n\n## Performance Budget\n- Layout solve for 20 items: < 100s\n- No allocations for typical layouts (stack buffer)\n\n## Location: ftui-layout crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:19:03.472657582Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:18.821559934Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-yzu","depends_on_id":"bd-10i.3.7","type":"blocks","created_at":"2026-01-31T22:22:18.821529657Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
